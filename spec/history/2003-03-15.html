<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><script>if (window.location.protocol === "http:" && window.location.hostname === "yaml.org") { window.location.href = window.location.href.replace( "http:", "https:"); }</script>
<BASE HREF="http://www.yaml.org/spec/">

<title>YAML Ain't Markup Language (YAML&trade;) 1.0</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="formatter" content="yiki2html" />
<style type="text/css" media="all">
body {
  font-family: sans-serif;
  background-color: white;
  color: black;
}

h1, h2, h3, h4, h5, h6 { color: #005a9c; }
h1                     { font: 170% sans-serif; }
    h2                 { font: 140% sans-serif; }
        h3             { font: 120% sans-serif; }
            h4         { font: 100% sans-serif; }
                h5     { font: 80% sans-serif; }
                    h6 { font: 60% sans-serif; }
            h4, h5, h6 { font-weight: bold; }


span.toc-2 { font-weight: bold; }
span.toc-3 { margin-left: 1em; }
span.toc-4 { margin-left: 3em; font-style: italic; }

table.example,
td.example-caption,
table.side-by-side      { width: 100%; }
td.left-column         { width: 50%; }
td.right-column        { width: 50%; }

table.example          { margin-bottom: 1em; }

td.bnf-comment,
td.yaml-type-uri,
td.yaml-type-shorthand,
td.yaml-format-comment { vertical-align: middle; }
td                     { vertical-align: top; }
td.yaml-type-label     { text-align: right; }

td.bnf-comment,
td.yaml-format-comment { font-style: italic; }
td.yaml-type-label     { font-weight: bold; }

dt { font-weight: bold; }
dd { margin-bottom: 1em; }

pre.example-text {
  background-color: #99ffff;
  border-bottom-style: ridge;
  border-left-style: ridge;
  border-right-style: ridge;
  border-top-style: ridge;
  padding-left: 1em;
  padding-right: 1em;
  padding-top: 1em;
  padding-bottom: 1em;
  margin-bottom: 0em;
}
pre.bnf,
pre.yaml-type-uri,
pre.yaml-type-shorthand,
pre.yaml-format-name,
pre.yaml-format-regexp { margin-right: 1em; margin-bottom: 0px; }
</style>
<link rel="icon" href="/favicon.svg" />
</head>
<body>
<div class='level-1'>
<h1>YAML Ain't Markup Language (YAML&trade;) 1.0</h1>
<div class='level-2'>
<h2>Working Draft 15 Mar 2003</h2>
<dl>
<dt>
Latest version:</dt>
<dd>
<a href="https://yaml.org/spec/">https://yaml.org/spec/</a></dd>
<dt>
Editors:</dt>
<dd>
<a href="mailto-oren-ben-kiki-org\">Oren Ben-Kiki</a>, <a href="mailto-cce-yaml-clarkevans-com\">Clark C. Evans</a>, <a href="mailto-ingy-ttul-org\">Brian Ingerson</a></dd>
</dl>
<p>Copyright &copy; 2001-2003 Oren Ben-Kiki, Clark Evans &amp; Brian Ingerson, all rights reserved. This document may be freely copied provided it is not modified.</p>
</div>
<div class='level-2'>
<h2>Status of this Document</h2>
<p>This specification is a working draft and reflects consensus reached by the members of the yaml-core mailing list. Any questions regarding this draft should be raised on this list at <a href="http-lists-sourceforge-net-lists-listinfo-yaml-core">http://lists.sourceforge.net/lists/listinfo/yaml-core</a>.</p>
<p>With this release of the YAML specificiation, we now encourage development of YAML processors, so that the design of YAML can be validated. The specification is still subject to change; however, such changes will be limited to polish and fixing any logical flaws and bugs.</p>
<p>Therefore, this is "Last Call" for changes; if you have a pet feature now is the very last time that it can be proposed before Release Canaidate status. Changes which would cause "Last Call" YAML streams to be invalid will be seriously considered only if absolutely necessary.</p>
</div>
<div class='level-2'>
<h2>Abstract</h2>
<p>YAML&trade; (rhymes with "camel") is a straightforward machine-parsable data serialization format designed for human readability and interaction with scripting languages such as Perl and Python. YAML is designed for data serialization, formatted dumping, configuration files, log files, Internet messaging and filtering. This specification describes the YAML information model and serialization format. Together with the <a href="http-www-unicode-org-\">Unicode</a> standard for characters, it provides all the information necessary to understand YAML Version 1.0 and to construct programs to process YAML information.</p>
</div>
<div class='toc-section'>
<div class='level-2'>
<h2>Table Of Contents</h2>
</div>
<div class='toc'>
<span class='toc-2'>1&nbsp;<a href='#.Introduction'>Introduction</a></span><br />
<span class='toc-3'>1.1&nbsp;<a href='#.Goals'>Goals</a></span><br />
<span class='toc-3'>1.2&nbsp;<a href='#.Design'>Design</a></span><br />
<span class='toc-3'>1.3&nbsp;<a href='#.Prior-Art'>Prior Art</a></span><br />
<span class='toc-3'>1.4&nbsp;<a href='#.Relation-to-XML'>Relation to XML</a></span><br />
<span class='toc-3'>1.5&nbsp;<a href='#.Terminology'>Terminology</a></span><br />
<span class='toc-2'>2&nbsp;<a href='#.Preview'>Preview</a></span><br />
<span class='toc-3'>2.1&nbsp;<a href='#.-preview-collection-Collections-'>Collections</a></span><br />
<span class='toc-3'>2.2&nbsp;<a href='#.-preview-struct-Structures-'>Structures</a></span><br />
<span class='toc-3'>2.3&nbsp;<a href='#.Scalars'>Scalars</a></span><br />
<span class='toc-3'>2.4&nbsp;<a href='#.Type-Family'>Type Family</a></span><br />
<span class='toc-3'>2.5&nbsp;<a href='#.Full-Length-Example'>Full Length Example</a></span><br />
<span class='toc-2'>3&nbsp;<a href='#.Syntax'>Syntax</a></span><br />
<span class='toc-3'>3.1&nbsp;<a href='#.Characters'>Characters</a></span><br />
<span class='toc-4'>3.1.1&nbsp;<a href='#.Character-Set'>Character Set</a></span><br />
<span class='toc-4'>3.1.2&nbsp;<a href='#.-syntax-encode-Encoding-'>Encoding</a></span><br />
<span class='toc-4'>3.1.3&nbsp;<a href='#.-syntax-indicators-Indicators-'>Indicators</a></span><br />
<span class='toc-4'>3.1.4&nbsp;<a href='#.Line-Breaks'>Line Breaks</a></span><br />
<span class='toc-4'>3.1.5&nbsp;<a href='#.Miscellaneous'>Miscellaneous</a></span><br />
<span class='toc-3'>3.2&nbsp;<a href='#.Space-Processing'>Space Processing</a></span><br />
<span class='toc-4'>3.2.1&nbsp;<a href='#.-syntax-indent-Indentation-'>Indentation</a></span><br />
<span class='toc-4'>3.2.2&nbsp;<a href='#.-syntax-throw-Throwaway-comments-'>Throwaway comments</a></span><br />
<span class='toc-3'>3.3&nbsp;<a href='#.YAML-Stream'>YAML Stream</a></span><br />
<span class='toc-4'>3.3.1&nbsp;<a href='#.Document'>Document</a></span><br />
<span class='toc-4'>3.3.2&nbsp;<a href='#.-syntax-directive-Directive-'>Directive</a></span><br />
<span class='toc-4'>3.3.3&nbsp;<a href='#.Text-Node'>Text Node</a></span><br />
<span class='toc-4'>3.3.4&nbsp;<a href='#.Node-Property'>Node Property</a></span><br />
<span class='toc-4'>3.3.5&nbsp;<a href='#.-syntax-trans-Transfer-Method-'>Transfer Method</a></span><br />
<span class='toc-4'>3.3.6&nbsp;<a href='#.-syntax-anchor-Anchor-'>Anchor</a></span><br />
<span class='toc-3'>3.4&nbsp;<a href='#.-syntax-alias-Alias-'>Alias</a></span><br />
<span class='toc-3'>3.5&nbsp;<a href='#.-syntax-collection-Collection-'>Collection</a></span><br />
<span class='toc-4'>3.5.1&nbsp;<a href='#.-syntax-sequence-Sequence-'>Sequence</a></span><br />
<span class='toc-4'>3.5.2&nbsp;<a href='#.-syntax-mapping-Mapping-'>Mapping</a></span><br />
<span class='toc-3'>3.6&nbsp;<a href='#.-syntax-scalar-Scalar-'>Scalar</a></span><br />
<span class='toc-4'>3.6.1&nbsp;<a href='#.-syntax-eol-norm-End-Of-line-Normalization-'>End Of line Normalization</a></span><br />
<span class='toc-4'>3.6.2&nbsp;<a href='#.Block-Modifiers'>Block Modifiers</a></span><br />
<span class='toc-4'>3.6.3&nbsp;<a href='#.-syntax-exp-indent-Explicit-Indentation-'>Explicit Indentation</a></span><br />
<span class='toc-4'>3.6.4&nbsp;<a href='#.-syntax-chomp-Chomping-'>Chomping</a></span><br />
<span class='toc-4'>3.6.5&nbsp;<a href='#.-syntax-literal-Literal-'>Literal</a></span><br />
<span class='toc-4'>3.6.6&nbsp;<a href='#.-syntax-folding-Folding-'>Folding</a></span><br />
<span class='toc-4'>3.6.7&nbsp;<a href='#.-syntax-folded-Folded-'>Folded</a></span><br />
<span class='toc-4'>3.6.8&nbsp;<a href='#.-syntax-single-Single-Quoted-'>Single Quoted</a></span><br />
<span class='toc-4'>3.6.9&nbsp;<a href='#.-syntax-escaping-Escaping-'>Escaping</a></span><br />
<span class='toc-4'>3.6.10&nbsp;<a href='#.-syntax-double-Double-Quoted-'>Double Quoted</a></span><br />
<span class='toc-4'>3.6.11&nbsp;<a href='#.-syntax-plain-Plain-'>Plain</a></span><br />
<span class='toc-2'>4&nbsp;<a href='#.Information-Models'>Information Models</a></span><br />
<span class='toc-3'>4.1&nbsp;<a href='#.Overview'>Overview</a></span><br />
<span class='toc-3'>4.2&nbsp;<a href='#.-model-native-Native-Language-Model-'>Native (Language) Model</a></span><br />
<span class='toc-4'>4.2.1&nbsp;<a href='#.-model-native-node-Native-Node-'>Native Node</a></span><br />
<span class='toc-4'>4.2.2&nbsp;<a href='#.-model-type-family-Type-Family-'>Type Family</a></span><br />
<span class='toc-4'>4.2.3&nbsp;<a href='#.Equivalence'>Equivalence</a></span><br />
<span class='toc-4'>4.2.4&nbsp;<a href='#.Documents-Stream'>Documents Stream</a></span><br />
<span class='toc-3'>4.3&nbsp;<a href='#.-model-graph-Graph-Generic-Model-'>Graph (Generic) Model</a></span><br />
<span class='toc-4'>4.3.1&nbsp;<a href='#.-model-format-Format-'>Format</a></span><br />
<span class='toc-4'>4.3.2&nbsp;<a href='#.Type-Family-Formats'>Type Family Formats</a></span><br />
<span class='toc-4'>4.3.3&nbsp;<a href='#.-model-graph-node-Graph-Node-'>Graph Node</a></span><br />
<span class='toc-4'>4.3.4&nbsp;<a href='#.Implicit-Types-and-Formats'>Implicit Types and Formats</a></span><br />
<span class='toc-3'>4.4&nbsp;<a href='#.-model-serial-Serial-Tree-Model-'>Serial (Tree) Model</a></span><br />
<span class='toc-4'>4.4.1&nbsp;<a href='#.-model-serial-node-Serial-Node-'>Serial Node</a></span><br />
<span class='toc-4'>4.4.2&nbsp;<a href='#.-model-alias-Alias-'>Alias</a></span><br />
<span class='toc-4'>4.4.3&nbsp;<a href='#.-model-pair-Pair-'>Pair</a></span><br />
<span class='toc-4'>4.4.4&nbsp;<a href='#.Serial-Mapping'>Serial Mapping</a></span><br />
<span class='toc-4'>4.4.5&nbsp;<a href='#.-model-precede-Ordering-'>Ordering</a></span><br />
<span class='toc-3'>4.5&nbsp;<a href='#.-model-text-Text-Syntax-Model-'>Text (Syntax) Model</a></span><br />
<span class='toc-4'>4.5.1&nbsp;<a href='#.-preview-style-Style-'>Style</a></span><br />
<span class='toc-4'>4.5.2&nbsp;<a href='#.Comment'>Comment</a></span><br />
<span class='toc-4'>4.5.3&nbsp;<a href='#.Directive'>Directive</a></span><br />
<span class='toc-4'>4.5.4&nbsp;<a href='#.Details'>Details</a></span><br />
<span class='toc-2'>5&nbsp;<a href='#.Type-Families'>Type Families</a></span><br />
<span class='toc-3'>5.1&nbsp;<a href='#.-trans-seq-Sequence-'>Sequence</a></span><br />
<span class='toc-3'>5.2&nbsp;<a href='#.-trans-map-Mapping-'>Mapping</a></span><br />
<span class='toc-3'>5.3&nbsp;<a href='#.-trans-str-String-'>String</a></span><br />
</div>
</div>
<div class='level-2'>
<h2><a id='.Introduction' name='.Introduction'>1 Introduction</a></h2>
<p>YAML Ain't Markup Language, abbreviated YAML, is both a human-readable data serialization format and processing model. This text describes the class of data objects called YAML document streams and partially describes the behavior of computer programs that process them.</p>
<p>YAML document streams encode in a textual form the native data constructs of modern scripting languages. Strings, arrays, hashes, and other user-defined data types are supported. A YAML document stream consists of a sequence of characters, some of which are considered part of the document's content, and others that are used to indicate document structure.</p>
<p>YAML information can be viewed in two primary ways, for machine processing and for human presentation. A YAML <em>processor</em> is a tool for converting information between these complementary views. It is assumed that a YAML processor does its work on behalf of another module, called an <em>application</em>. This specification describes the required behavior of a YAML processor. It describes how a YAML processor must read or write YAML document streams and the information structures it must provide to or obtain from the application.</p>
<div class='level-3'>
<h3><a id='.Goals' name='.Goals'>1.1 Goals</a></h3>
<p>The design goals for YAML are:</p>
<ol>
<li>
YAML documents are very readable by humans.</li>
<li>
YAML interacts well with scripting languages.</li>
<li>
YAML uses host languages' native data structures.</li>
<li>
YAML has a consistent model to support generic tools.</li>
<li>
YAML enables stream-based processing.</li>
<li>
YAML is expressive and extensible.</li>
<li>
YAML is easy to implement.</li>
</ol>
<p>YAML's initial direction was set by the markup language discussions among <a href="http-www-docuverse-com-smldev-\">SML-DEV</a> members. YAML was also conceived with experience gained from the construction and deployment of Brian Ingerson's Perl module <a href="http-search-cpan-org-doc-INGY-Data-Denter-0-13-Denter-pod\">Data::Denter</a>. Since then YAML has matured through the ideas and support it has received from its user community.</p>
</div>
<div class='level-3'>
<h3><a id='.Design' name='.Design'>1.2 Design</a></h3>
<p>YAML was first conceived as notation for a simple set of primatives, the <a href="#model-sequence">sequence</a>, the <a href="#model-mapping">mapping</a> and the <a href="#model-scalar">scalar</a>, which, when used recursively to form a graph structure, are strong enough for most machine processing needs. By sequence we mean a ordered collection, by mapping we mean an unordered association of unique keys to values, and by scalar we mean a series of unicode characters. These primitives map cleanly to most modern programming languages; the sequence corresponds to a Perl array and a Python list, the mapping corresponds to a Perl hashtable and a Python dictionary. This basis is also formally justified, as both mapping and sequence are mathematical functions with well defined characteristics. With this core model, YAML supports machine processing with a balance of pratical motivation and theory.</p>
<p>To meet the needs of serialization and human presentation, YAML has many syntatical aspects beyond the primitives described above. As a graph is flattened into a tree, ordering is imposed upon mapping keys and an alias mechaism is used to write subsequent occurances of duplicate nodes. To enhance readability, various writing styles are provided for different aesthetic needs. Further, a comment mechanism allows for annotation othogonal to the "content" of a YAML stream. YAML syntax also has other details, such as placement of line breaks and choice of escaping and scalar formats. While these aspects are essential to a human presentation of YAML, they are not needed for machine processing.</p>
<p>This split between machine processing and human presentation creates an inherent tension. While it may be tempting to drive machine processing with comments, key order, styles and other presentation information, this would greatly complicate the definition and operation of generic tools. Although one could argue that their YAML data is sufficently isolated, information is often used in ways unforseen. Therefore, applications should only rely upon the formal definition of YAML's primitives to drive processing. For example, sequences should be used when order is important for machine processing even though mapping key order may be available. Likewise, duplicate keys should never be used, even though a parser may report them without warning. Overall, this distinction is one of intent. Applications which respect the split between human presentation and machine processing will enjoy the ability to use generic tools such as path expressions evaluators, graph transformation languages, or schema validators.</p>
<p>This separation does not prevent YAML processors from providing mechanisms to report or handle presentation aspects. Human readability is a prime directive for YAML. Therefore, a YAML processor may provide a shadow or wrapper mechanism to maintain and provide access to presentation aspects of a YAML text. In this way an application can have influence over how its information will be written to a stream for the best human impact. Since presentation aspects may be the same for a large class of YAML documents, a stylesheet could also be used to provide preferred key ordering, syntax styles, comments, and other presentation oriented instructions.</p>
</div>
<div class='level-3'>
<h3><a id='.Prior-Art' name='.Prior-Art'>1.3 Prior Art</a></h3>
<p>YAML integrates and builds upon structures and concepts described by <a href="http-cm-bell-labs-com-cm-cs-cbook-index-html\">C</a>, <a href="http-java-sun-com-\">Java</a>, <a href="http-www-perl-org-\">Perl</a>, <a href="http-www-python-org-\">Python</a>, <a href="http-www-ruby-lang-org-\">Ruby</a>, <a href="http-www-ietf-org-rfc-rfc0822-txt\">RFC0822</a> (MAIL), <a href="http-www-ics-uci-edu-pub-ietf-html-rfc1866-txt\">RFC1866</a> (HTML), <a href="http-www-ietf-org-rfc-rfc2045-txt\">RFC2045</a> (MIME), <a href="http-www-ietf-org-rfc-rfc2396-txt\">RFC2396</a> (URI), <a href="http-www-saxproject-org-\">SAX</a>, <a href="http-www-w3-org-TR-SOAP\">SOAP</a> and <a href="http-www-w3-org-TR-REC-xml-html\">XML</a>.</p>
<p>YAML's core type system is based on the serialization requirements of Perl, Python and Ruby. YAML directly supports both <a href="#preview-style">scalar</a> (<a href="#trans-str">string</a>) values and <a href="#preview-collection">collection</a> ( <a href="#trans-seq">array</a>, <a href="#trans-map">hash</a>) values. Support for common types enables programmers to use their language's native data constructs for YAML manipulation, instead of requiring a special document object model (DOM).</p>
<p>Like XML's SOAP, the YAML serialization supports native graph structures through a rich <a href="#model-alias">alias</a> mechanism. Also like SOAP, YAML provides for <a href="#model-type-family">application-defined types</a>. This allows YAML to serialize rich data structures required for modern distributed computing. YAML provides unique global <a href="#syntax-trans">type names</a> using a namespace mechanism inspired by Java's DNS based package naming convention and XML's URI based namespaces.</p>
<p>YAML's <a href="#syntax-indent">block scoping</a> is similar to Python's. In YAML, the extent of a node is indicated by its column. YAML's <a href="#syntax-literal">literal</a> scalar leverages this by enabling formatted text to be cleanly mixed within an indented structure without troublesome escaping. Further, YAML's block indenting provides for easy inspection of the document's structure.</p>
<p>Motivated by HTML's end-of-line normalization, YAML's <a href="#syntax-folded">folded</a> scalar introduces a unique method of handling white space. In YAML, single line breaks may be <a href="#syntax-folding">folded</a> into a single space, while empty lines represent line break characters. This technique allows for paragraphs to be word-wrapped without affecting the canonical form of the content.</p>
<p>YAML's <a href="#syntax-double">double quoted</a> scalar uses familar C-style <a href="#syntax-escaping">escape sequences</a>. This enables ASCII representation of non-printable or 8-bit (ISO 8859-1) characters such as '<a href="#ns-esc-8-bit"><code>\x3B</code></a>'. 16-bit Unicode and 32-bit (ISO/IEC 10646) characters are supported with escape sequences such as '<a href="#ns-esc-16-bit"><code>\u003B</code></a>' and '<a href="#ns-esc-32-bit"><code>\U0000003B</code></a>'.</p>
<p>The syntax of YAML was motivated by Internet Mail (RFC0822) and remains partially compatible with this standard. Further, YAML borrows the idea of having <a href="#c-l-yaml-stream">multiple documents</a> from MIME (RFC2045). YAML's top-level production is a <a href="#preview-struct">stream</a> of independent documents; ideal for message-based distributed processing systems.</p>
<p>YAML was designed to have an incremental interface that includes both a pull-style input stream and a push-style (SAX-like) output stream interfaces. Together this enables YAML to support the processing of large documents, such as a transaction log, or continuous streams, such as a feed from a production machine.</p>
</div>
<div class='level-3'>
<h3><a id='.Relation-to-XML' name='.Relation-to-XML'>1.4 Relation to XML</a></h3>
<p>Newcomers to YAML often search for its correlation to the eXtensible Markup Language (XML). While the two languages may actually compete in several application domains, there is no direct correlation between them. YAML is primarily a data serialization language. XML is often used for various types of data serialization but that is not its fundamental design goal.</p>
<p>There are many differences between YAML and XML. XML was designed to be backwards compatible with Standard Generalized Markup Language (SGML) and thus had many design constraints placed on it that YAML does not share. Also XML, inheriting SGML's legacy, is designed to support structured documents, where YAML is more closely targeted at messaging and native data structures. Where XML is a pioneer in many domains, YAML is the result of many lessons from the XML community.</p>
<p>The YAML and XML <em>information models</em> are starkly different. In XML, the primary construct is an attributed tree, where each element has an ordered, named list of children and an unordered mapping of names to strings. In YAML, the primary constructs are <a href="#model-sequence">sequence</a> (natively stored as an array), <a href="#model-mapping">mapping</a> (natively stored as a hash) and <a href="#model-scalar">scalar</a> values (string, integer, floating point). This difference is critical since YAML's model is directly supported by native data structures in most modern programming languages, where XML's model requires mapping conventions, or an alternative programming component (e.g. a document object model).</p>
<p>It should be mentioned that there are ongoing efforts to define standard XML/YAML mappings. This generally requires that a subset of each language be used.</p>
</div>
<div class='level-3'>
<h3><a id='.Terminology' name='.Terminology'>1.5 Terminology</a></h3>
<p>The terminology used to describe YAML is defined in the body of this specification. The terms defined in the following list are used in building those definitions and in describing the actions of a YAML processor:</p>
<dl>
<dt>
may</dt>
<dd>
Conformant YAML streams and processors are permitted to but need not behave as described.
</dd>
<dt>
should</dt>
<dd>
Conformant YAML streams and processors are encouraged to behave as described, but may do otherwise if a warning message is provided to the user and any deviant behavior requires conscious effort to enable (i.e. a non-default setting).
</dd>
<dt>
must</dt>
<dd>
Conformant YAML streams and processors are required to behave as described, otherwise they are in error.
</dd>
<dt>
error</dt>
<dd>
A violation of the rules of this specification; results are undefined. Conforming software must detect and report an error and may recover from it.
</dd>
</dl>
</div>
</div>
<div class='level-2'>
<h2><a id='.Preview' name='.Preview'>2 Preview</a></h2>
<p>This section provides a quick glimpse into the expressive power of YAML. It is not expected that the first-time reader grok all of the examples. Rather, these selections are used as motivation for the remainder of the specification.</p>
<div class='level-3'>
<h3><a id='.-preview-collection-Collections-' name='.-preview-collection-Collections-'>2.1 <a id="preview-collection" name="preview-collection">Collections</a></a></h3>
<p>YAML's block collections use indentation for scope and begin each member on its own line. Block sequences indicate each member with a dash&nbsp;(<code>-</code>). Block mappings use a colon to mark each (key:&nbsp;value) pair.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
- Mark McGwire
- Sammy Sosa
- Ken Griffey&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>A1</td>
<td class='example-caption'>Sequence of scalars<br />
(ball players)
</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
hr:  65
avg: 0.278
rbi: 147&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>A2</td>
<td class='example-caption'>Mapping of scalars to scalars<br />
(player statistics)
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
american:
   - Boston Red Sox
   - Detroit Tigers
   - New York Yankees
national:
   - New York Mets
   - Chicago Cubs
   - Atlanta Braves&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>A3</td>
<td class='example-caption'>Mapping of scalars to sequences<br />
(ball clubs in each league)
</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
-
  name: Mark McGwire
  hr:   65
  avg:  0.278
-
  name: Sammy Sosa
  hr:   63
  avg:  0.288&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>A4</td>
<td class='example-caption'>Sequence of mappings<br />
(players' statistics)
</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
<p>YAML also has in-line flow styles for compact notation. The flow sequence is written as a comma separated list within square brackets. In a similar manner, the flow mapping uses curley braces.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
- [ name         , hr , avg   ]
- [ Mark McGwire , 65 , 0.278 ]
- [ Sammy Sosa   , 63 , 0.288 ]&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>A5</td>
<td class='example-caption'>Sequence of sequences</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
Mark McGwire: {hr: 65, avg: 0.278}
Sammy Sosa:   {hr: 63,
               avg: 0.288}&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>A6</td>
<td class='example-caption'>Mapping of mappings</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
</div>
<div class='level-3'>
<h3><a id='.-preview-struct-Structures-' name='.-preview-struct-Structures-'>2.2 <a id="preview-struct" name="preview-struct">Structures</a></a></h3>
<p>YAML uses three dashes&nbsp;(<code>---</code>) to separate documents within a stream (file or socket). Comment lines begin with the pound sign&nbsp;(<code>#</code>). Repeated nodes are first marked with the ampersand&nbsp;(<code>&amp;</code>) and then referenced with an asterisk&nbsp;(<code>*</code>) thereafter.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
---
name: Mark McGwire
hr:   65
avg:  0.278
---
name: Sammy Sosa
hr:   63
avg:  0.288&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>B1</td>
<td class='example-caption'>Two documents; one stream<br />
(players' statistics)
</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
# Ranking of players by
# 1998 season home runs.
---
- Mark McGwire
- Sammy Sosa
- Ken Griffey

&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>B2</td>
<td class='example-caption'>Document with leading comment</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
hr: # 1998 hr ranking
   - Mark McGwire
   - Sammy Sosa
rbi:
   # 1998 rbi ranking
   - Sammy Sosa
   - Ken Griffey&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>B3</td>
<td class='example-caption'>Single document with two comments</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
hr:
   - Mark McGwire
   # Following node labeled SS
   - &amp;amp;SS Sammy Sosa
rbi:
   - *SS # Subsequent occurance
   - Ken Griffey&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>B4</td>
<td class='example-caption'>Node for <code>Sammy Sosa</code> appears<br />
twice in this document
</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
<p>The question mark indicates a complex key. Within a block sequence, mapping pairs can start immediately following the dash.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
? # PLAY SCHEDULE
  - Detroit Tigers
  - Chicago Cubs
:
  - 2001-07-23

? [ New York Yankees,
    Atlanta Braves ]
: [ 2001-07-02, 2001-08-12,
    2001-08-14 ]&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>B5</td>
<td class='example-caption'>Mapping between sequences</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
invoice: 34843
date   : 2001-01-23
bill-to: Chris Dumars
product:
   - item    : Super Hoop
     quantity: 1
   - item    : Basketball
     quantity: 4
   - item    : Big Shoes
     quantity: 1&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>B6</td>
<td class='example-caption'>Sequence key shortcut</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
</div>
<div class='level-3'>
<h3><a id='.Scalars' name='.Scalars'>2.3 Scalars</a></h3>
<p>Scalar values can be written in block form using a literal style&nbsp;(<code>|</code>) where all new lines count. Or they can be written with the folded style&nbsp;(<code>&gt;</code>) for content that can be word wrapped. In the folded style, newlines are treated as a space unless they are part of a blank or indented line.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
--- |
  \/|\/|
  / |  |_
&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>C1</td>
<td class='example-caption'>In literals, newlines are preserved</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
--- &gt;
    Mark McGwire's
    year was crippled
    by a knee injury.&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>C2</td>
<td class='example-caption'>In folded, newlines are treated as a space</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
--- &gt;
 Sammy Sosa completed another
 fine season with great stats.

   63 Home Runs
   0.288 Batting Average

 What a year!&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>C3</td>
<td class='example-caption'>Newlines preserved for indented and blank lines</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
name: Mark McGwire
accomplishment: &gt;
   Mark set a major league
   home run record in 1998.
stats: |
   65 Home Runs
   0.278 Batting Average
&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>C4</td>
<td class='example-caption'>Indentation determines scope</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
<p>YAML's flow scalars include the plain style (most examples thus far) and quoted styles. The double quoted style provides escape sequences. Single quoted style is useful when escaping is not needed. All flow scalars can span multiple lines; intermediate whitespace is trimmed to a single space.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
unicode: "Sosa did fine.\u263A"
control: "\b1998\t1999\t2000\n"
hexesc:  "\x13\x10 is \r\n"

single: '"Howdy!" he cried.'
quoted: ' # not a ''comment''.'
tie-fighter: '|\-*-/|'&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>C5</td>
<td class='example-caption'>Quoted scalars</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
plain:
   This unquoted scalar
   spans many lines.
quoted: "So does this
   quoted scalar.\n"

&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>C6</td>
<td class='example-caption'>Multiline flow scalars</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
</div>
<div class='level-3'>
<h3><a id='.Type-Family' name='.Type-Family'>2.4 Type Family</a></h3>
<p>In YAML, plain (unquoted) scalars are given an implicit type depending on the application. YAML's <a href="#trans-repository">type repository</a> includes integers, floating point values, timestamps, null, boolean, and string values.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
canonical: 12345
decimal: +12,345
sexagecimal: 3:25:45
octal: 014
hexadecimal: 0xC
&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>D1</td>
<td class='example-caption'>Integers</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
canonical: 1.23015e+3
exponential: 12.3015e+02
sexagecimal: 20:30.15
fixed: 1,230.15
negative infinity: (-inf)
not a number: (NaN)&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>D2</td>
<td class='example-caption'>Floating point</td>
</tr>
</table>
</td>
</tr>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
null: ~
true: y
false: n
string: '12345'&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>D3</td>
<td class='example-caption'>Miscellaneous</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
canonical: 2001-12-15T02:59:43.1Z
iso8601:  2001-12-14t21:59:43.10-05:00
spaced:  2001-12-14 21:59:43.10 -05:00
date:   2002-12-14&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>D4</td>
<td class='example-caption'>Timestamps</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
<p>Explicit typing is denoted with the bang&nbsp;(<code>!</code>) symbol. Application types should include a domain name and may use the caret&nbsp;(<code>^</code>) to abbreviate subsequent types.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
---
not-date: !str 2002-04-28
picture: !binary#base64 |
 R0lGODlhDAAMAIQAAP//9/X
 17unp5WZmZgAAAOfn515eXv
 Pz7Y6OjuDg4J+fn5OTk6enp
 56enmleECcgggoBADs=

hmm: !somewhere.com,2002/type |
 family above is shorthand for
 taguri:somewhere.com,2002:type
&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>D5</td>
<td class='example-caption'>Various explicit families</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
--- !clarkevans.com,2002/graph/^shape
  # !clarkevans.com,2002/graph/circle
- !^circle
  center: &amp;ORIGIN {x: 73, y: 129}
  radius: 7
- !^line
  start: *ORIGIN
  finish: { x: 89, y: 102 }
- !^text
  start: *ORIGIN
  color: 0xFFEEBB
  value: Pretty vector drawing.&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>D6</td>
<td class='example-caption'>Application specific family</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
</div>
<div class='level-3'>
<h3><a id='.Full-Length-Example' name='.Full-Length-Example'>2.5 Full Length Example</a></h3>
<p>Below are two full-length examples of YAML. On the left is a sample invoice; on the right is a sample log file.</p>
<table summary='Two Columns' class='side-by-side'>
<tr>
<td class='left-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
--- !clarkevans.com,2002/^invoice
invoice: 34843
date   : 2001-01-23
bill-to: &amp;id001
    given  : Chris
    family : Dumars
    address:
        lines: |
            458 Walkman Dr.
            Suite #292
        city    : Royal Oak
        state   : MI
        postal  : 48046
ship-to: *id001
product:
    - sku         : BL394D
      quantity    : 4
      description : Basketball
      price       : 450.00
    - sku         : BL4438H
      quantity    : 1
      description : Super Hoop
      price       : 2392.00
tax  : 251.42
total: 4443.52
comments:
    Late afternoon is best.
    Backup contact is Nancy
    Billsmer @ 338-4338.&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>E1</td>
<td class='example-caption'>Invoice</td>
</tr>
</table>
</td>
<td class='right-column'>
<table summary='Example' class='example'>
<tr>
<td colspan='2' class='example-text'>
<pre class='example-text'>
---
Time: 2001-11-23 15:01:42 -05:00
User: ed
Warning:
  This is an error message
  for the log file
---
Time: 2001-11-23 15:02:31 -05:00
User: ed
Warning:
  A slightly different error
  message.
---
Date: 2001-11-23 15:03:17 -05:00
User: ed
Fatal:
  Unknown variable "bar"
Stack:
  - file: TopClass.py
    line: 23
    code: |
      x = MoreObject("345\n")
  - file: MoreClass.py
    line: 58
    code: |-
      foo = bar


&nbsp;</pre>
</td>
</tr>
<tr>
<td class='example-id'>E2</td>
<td class='example-caption'>Log file</td>
</tr>
</table>
</td>
</tr>
</tr>
</table>
</div>
</div>
<div class='level-2'>
<h2><a id='.Syntax' name='.Syntax'>3 Syntax</a></h2>
<p>Following are the BNF productions defining the syntax of YAML streams.</p>
<div class='level-3'>
<h3><a id='.Characters' name='.Characters'>3.1 Characters</a></h3>
<p>Characters are the basis for a YAML stream. Below is a general definition of a character followed by several characters that have specific meaning in particular contexts.</p>
<div class='level-4'>
<h4><a id='.Character-Set' name='.Character-Set'>3.1.1 Character Set</a></h4>
<p>YAML streams use a subset of the Unicode character set. A YAML parser must accept all printable ASCII characters, the space, tab, line break, and all Unicode characters beyond 0x9F. A YAML emitter must only produce those characters accepted by the parser, but should also <a href="#syntax-escaping">escape</a> all non-printable Unicode characters if a character table is readily available.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-printable' id='c-printable'><code>[001]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-printable ::=
    #x9 | #xA | #xD
  | &#91;#x20-#x7E] | #x85
  | &#91;#xA0-#xD7FF]
  | &#91;#xE000-#xFFFD]
  | &#91;#x10000-#x10FFFF]&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;characters as defined by the Unicode standard, excluding most control characters and the surrogate blocks&nbsp;&#42;/</td>
</tr>
</table>
<p>The range above explicitly excludes the surrogate block <code>&#91;#xD800-#xDFFF]</code>, DEL <code>0x7F</code>, the C0 control block <code>&#91;#x0-#x1F]</code>, the C1 control block <code>&#91;#x80-#x9F]</code>, <code>#xFFFE</code> and <code>#xFFFF</code>. Note that in UTF-16, characters above <code>#xFFFF</code> are represented with a surrogate pair. DEL and characters in the C0 and C1 control block may be represented in a YAML stream using <a href="#syntax-escaping">escape sequences</a>.</p>
</div>
<div class='level-4'>
<h4><a id='.-syntax-encode-Encoding-' name='.-syntax-encode-Encoding-'>3.1.2 <a id="syntax-encode" name="syntax-encode">Encoding</a></a></h4>
<p>A YAML parser is required to support the UTF-32, UTF-16 and UTF-8 character encodings. If an input stream does not begin with a <a href="#c-byte-order-mark">byte order mark</a>, the encoding shall be UTF-8. Otherwise the encoding shall be UTF-32 (LE or BE), UTF-16 (LE or BE) or UTF-8, as signaled by the byte order mark. Note that as YAML files may only contain printable characters, this does not raise any ambiguities. For more information about the byte order mark and the Unicode character encoding schemes see the Unicode <a href="http-www-unicode-org-unicode-faq-utf_bom-html\">FAQ</a>.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-byte-order-mark' id='c-byte-order-mark'><code>[002]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-byte-order-mark ::= #xFEFF&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;the Unicode ZERO WIDTH NON-BREAKING SPACE character used to mark a UTF-32 or UTF-16 stream and determine byte ordering&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-4'>
<h4><a id='.-syntax-indicators-Indicators-' name='.-syntax-indicators-Indicators-'>3.1.3 <a id="syntax-indicators" name="syntax-indicators">Indicators</a></a></h4>
<p>Indicators are special characters that are used to describe the structure of a YAML document.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-sequence-entry' id='c-sequence-entry'><code>[003]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-sequence-entry ::= '-'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a sequence entry&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-mapping-entry' id='c-mapping-entry'><code>[004]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-mapping-entry ::= ':'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;separates a key from its value&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-sequence-start' id='c-sequence-start'><code>[005]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-sequence-start ::= '['&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;starts a flow sequence collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-sequence-end' id='c-sequence-end'><code>[006]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-sequence-end ::= ']'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ends a flow sequence collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-mapping-start' id='c-mapping-start'><code>[007]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-mapping-start ::= '{'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;starts a flow mapping collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-mapping-end' id='c-mapping-end'><code>[008]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-mapping-end ::= '}'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ends a flow mapping collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-collect-entry' id='c-collect-entry'><code>[009]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-collect-entry ::= ','&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;separates flow collection entries&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-top-key' id='c-top-key'><code>[010]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-top-key ::= '?'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a complex key&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-alias' id='c-alias'><code>[011]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-alias ::= '*'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates an alias node&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-anchor' id='c-anchor'><code>[012]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-anchor ::= '&amp;'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates an anchor-name property&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-transfer' id='c-transfer'><code>[013]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-transfer ::= '!'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a transfer method property&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-literal' id='c-literal'><code>[014]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-literal ::= '|'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a literal scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-folded' id='c-folded'><code>[015]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-folded ::= '&gt;'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a folded scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-single-quote' id='c-single-quote'><code>[016]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-single-quote ::= '''&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-double-quote' id='c-double-quote'><code>[017]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-double-quote ::= '"'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-throwaway' id='c-throwaway'><code>[018]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-throwaway ::= '#'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a throwaway comment&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-directive' id='c-directive'><code>[019]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-directive ::= '%'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a directive&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-reserved' id='c-reserved'><code>[020]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-reserved ::= '@' | '&#96;'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;reserved for future use&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-4'>
<h4><a id='.Line-Breaks' name='.Line-Breaks'>3.1.4 Line Breaks</a></h4>
<p>The Unicode standard defines several <a href="#b-char">line break characters</a>. These line breaks can be grouped into two categories. <a href="#b-specific">Specific line breaks</a> have well-defined semantics for breaking text into lines and paragraphs. The semantics of <a href="#b-generic">generic line break</a> characters is not defined beyond "ending a line".</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='b-line-feed' id='b-line-feed'><code>[021]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-line-feed ::= #xA&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII line feed (LF)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-carriage-return' id='b-carriage-return'><code>[022]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-carriage-return ::= #xD&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII carriage return (CR)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-next-line' id='b-next-line'><code>[023]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-next-line ::= #x85&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;Unicode next line (NEL)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-line-separator' id='b-line-separator'><code>[024]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-line-separator ::= #x2028&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;Unicode line separator (LS)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-paragraph-separator' id='b-paragraph-separator'><code>[025]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-paragraph-separator ::= #x2029&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;Unicode paragraph separator (PS)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-char' id='b-char'><code>[026]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-char ::=
    <a href="#b-line-feed">b-line-feed</a>
  | <a href="#b-carriage-return">b-carriage-return</a>
  | <a href="#b-next-line">b-next-line</a>
  | <a href="#b-line-separator">b-line-separator</a>
  | <a href="#b-paragraph-separator">b-paragraph-separator</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;line break characters&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-generic' id='b-generic'><code>[027]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-generic ::=
    ( <a href="#b-carriage-return">b-carriage-return</a>
      <a href="#b-line-feed">b-line-feed</a> )<em>greedy</em>
  | <a href="#b-carriage-return">b-carriage-return</a>
  | <a href="#b-line-feed">b-line-feed</a>
  | <a href="#b-next-line">b-next-line</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;line break with non-specific semantics&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-specific' id='b-specific'><code>[028]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-specific ::=
    <a href="#b-line-separator">b-line-separator</a>
  | <a href="#b-paragraph-separator">b-paragraph-separator</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;line break with specific semantics&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-any' id='b-any'><code>[029]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-any ::=
  <a href="#b-generic">b-generic</a> | <a href="#b-specific">b-specific</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;any non-content line break&nbsp;&#42;/</td>
</tr>
</table>
<p>Outside scalar text content, YAML allows <a href="#b-any">any line break</a> to be used to terminate lines, and in most cases also allows such line breaks to be preceded by <a href="#s-b-trailing-comment">trailing comment</a> characters. On output, a YAML emitter is free to emit such line breaks using whatever convention is most appropriate. An emitter should avoid emitting trailing line spaces.</p>
</div>
<div class='level-4'>
<h4><a id='.Miscellaneous' name='.Miscellaneous'>3.1.5 Miscellaneous</a></h4>
<p>This section includes several common character range definitions.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='nb-char' id='nb-char'><code>[030]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-char ::= <a href="#c-printable">c-printable</a> - <a href="#b-char">b-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;characters valid in a line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-char' id='s-char'><code>[031]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-char ::= #x9 | #x20&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;white space valid in a line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-char' id='ns-char'><code>[032]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-char ::= <a href="#nb-char">nb-char</a> - <a href="#s-char">s-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;non-space characters valid in a line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ascii-letter' id='ns-ascii-letter'><code>[033]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ascii-letter ::=
  &#91;#x41-#x5A] | &#91;#x61-#x7A]&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII letters, A-Z or a-z&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-decimal-digit' id='ns-decimal-digit'><code>[034]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-decimal-digit ::= &#91;#x30-#x39]&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;0-9&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-hex-digit' id='ns-hex-digit'><code>[035]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-hex-digit ::=
    <a href="#ns-decimal-digit">ns-decimal-digit</a>
  | &#91;#x41-#x46] | &#91;#x61-#x66]&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;0-9, A-F or a-f&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-word-char' id='ns-word-char'><code>[036]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-word-char ::=
    <a href="#ns-decimal-digit">ns-decimal-digit</a>
  | <a href="#ns-ascii-letter">ns-ascii-letter</a> | '-'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;characters valid in a word&nbsp;&#42;/</td>
</tr>
</table>
</div>
</div>
<div class='level-3'>
<h3><a id='.Space-Processing' name='.Space-Processing'>3.2 Space Processing</a></h3>
<p>YAML streams use lines and spaces to convey structure. This requires special processing rules for white space (<a href="#s-char">space and tab</a>).</p>
<div class='level-4'>
<h4><a id='.-syntax-indent-Indentation-' name='.-syntax-indent-Indentation-'>3.2.1 <a id="syntax-indent" name="syntax-indent">Indentation</a></a></h4>
<p>In a YAML text representation, structure is determined from indentation, where indentation is defined as a line break character followed by zero or more space characters.</p>
<p>Tab characters are not allowed in indentation. Since different systems treat tabs differently, portability problems are a concern. Therefore, YAML's tab policy is conservative; they are not allowed. Note that most modern editors may be configured so that pressing the tab key results in the insertion of an appropriate number of spaces.</p>
<p>With one notable exception, a node must be more indented than its parent node. All sibling nodes must use the exact same indentation level. However the content of each such node may be indented independently.</p>
<p>The indentation level is used exclusively to delineate structure. Indentation characters are otherwise ignored. In particular, they are never taken to be a part of the the serialized text.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='i-spaces-n-' id='i-spaces-n-'><code>[037]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-spaces(n) ::= #x20 x n&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;specific level of indentation&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-spaces-n-' id='i-spaces-n-'><code>[038]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-spaces(&lt;n) ::= <a href="#i-spaces-n-">i-spaces(m)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;for some specific <code>m</code> such that <code>m</code> &lt; <code>n</code>&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-spaces-n-' id='i-spaces-n-'><code>[039]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-spaces(&lt;=n) ::= <a href="#i-spaces-n-">i-spaces(m)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;for some specific <code>m</code> such that <code>m</code> &lt;= <code>n</code>&nbsp;&#42;/</td>
</tr>
</table>
<p>Since the YAML stream depends upon indentation level to delineate blocks, additional productions are a function of an integer, based on the <code><a href="#i-spaces-n-">i-spaces(n)</a></code>, <code><a href="#i-spaces-n-">i-spaces(&lt;n)</a></code> and <code><a href="#i-spaces-n-">i-spaces(&lt;=n)</a></code> productions above. In some cases the notation <code><em>production</em>(any)</code> is used; it is a shorthand for "<code><em>production</em>(n)</code> for some specific of <code>n</code> such that <code>n</code>&nbsp;&gt;=&nbsp;0".</p>
<p>The '<code>-</code>' <a href="#c-sequence-entry">sequence entry indicator</a> is perceived by people to be part of the indentation. Hence the indentation rules are slightly more flexible when dealing with this indicator. First, a block sequence need not be indented relative to its parent node, unless that node is a block sequence entry. For example:</p>
<pre class='example-text'>
a key in a mapping at indentation level 0:
# The value for this key is a block sequence.
- This sequence is also at indentation level 0.
-   Another entry in the sequence.
- # The value of this entry is a nested sequence.
 - This nested sequence must be
  indented at least to level 1.
 - Another entry in the nested sequence.
- Last entry in block sequence at indentation level 0.
second key in mapping: at indentation level 0.&nbsp;</pre>
<p>In addition, in the special case when the value of a sequence entry is a block collection, and neither the nested block collection nor its first entry have any properties specified (type family or anchor), then this first entry may be specified in the same line as the '<code>-</code>' indicator of the containing sequence entry. In this case both the '<code>-</code>' and any following spaces are counted as part of the indentation. For example:</p>
<pre class='example-text'>
- This sequence is not indented.
-   map-in-seq: further indented by four.
    this key: is also further indented by four.
-  - seq-in-seq; further indented by three.
   -    second entry in nested sequence.
- Last entry in top sequence.&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-throw-Throwaway-comments-' name='.-syntax-throw-Throwaway-comments-'>3.2.2 <a id="syntax-throw" name="syntax-throw">Throwaway comments</a></a></h4>
<p>Throwaway comments have no effect whatsoever on the data serialized in the stream. Their usual purpose is to communicate between the human maintainers of the file. A typical example is comments in a configuration file.</p>
<p>A throwaway comment always spans to the end of a line. It consists of white spaces, optionally followed by a '<code><a href="#c-throwaway">#</a></code>' indicator and arbitrary comment characters to the end of the line.</p>
<p>Outside text content, empty lines or lines containing only white space are taken to be implicit throwaway comment lines. Lines containing indentation followed by '<code><a href="#c-throwaway">#</a></code>' and comment characters are taken to be explicit throwaway comment lines.</p>
<p>A throwaway comment may appear before a document node or following any node. It may not appear inside a scalar node, but may precede or follow it.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-nb-throwaway-comment' id='c-nb-throwaway-comment'><code>[040]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-nb-throwaway-comment ::=
  <a href="#c-throwaway">c-throwaway</a> <a href="#nb-char">nb-char</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;comment trailing a line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-comment-n-' id='l-comment-n-'><code>[041]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-comment(n) ::=
    <a href="#l-empty-comment-n-">l-empty-comment(n)</a>
  | <a href="#l-text-comment-n-">l-text-comment(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;types of comment lines&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-empty-comment-n-' id='l-empty-comment-n-'><code>[042]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-empty-comment(n) ::=
  <a href="#i-spaces-n-">i-spaces(&lt;=n)</a> <a href="#b-any">b-any</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;empty throwaway comment line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-text-comment-n-' id='l-text-comment-n-'><code>[043]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-text-comment(n) ::=
  <a href="#i-spaces-n-">i-spaces(&lt;n)</a>
  <a href="#c-nb-throwaway-comment">c-nb-throwaway-comment</a>
  <a href="#b-any">b-any</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;explicit throwaway comment line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-b-trailing-comment' id='s-b-trailing-comment'><code>[044]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-b-trailing-comment ::=
  ( <a href="#s-char">s-char</a>+
    <a href="#c-nb-throwaway-comment">c-nb-throwaway-comment</a>? )?
  <a href="#b-any">b-any</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;trailing non-content spaces, comment and line break&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
###The first tree lines of this stream

## are comments (the second one is empty).
this: |   # Comments may trail block indicators.
    contains three lines of text.
    The third one starts with a
    # character. This isn't a comment.

# The last three lines of this stream
# are comments (the first line is empty).&nbsp;</pre>
</div>
</div>
<div class='level-3'>
<h3><a id='.YAML-Stream' name='.YAML-Stream'>3.3 YAML Stream</a></h3>
<p>A sequence of bytes is a YAML stream if, taken as a whole, it complies with the following production. Note that an empty stream is a valid YAML stream containing no documents.</p>
<p><a href="#syntax-encode">Encoding</a> is assumed to be UTF-8 unless explicitly specified by including a byte order mark as the first character of the stream. While a byte order mark may also appear before additional document headers, the same encoding must be used for all documents contained in a YAML stream.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-l-yaml-stream' id='c-l-yaml-stream'><code>[045]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-l-yaml-stream ::=
  ( <a href="#c-l-before-document">c-l-before-document</a>
    <a href="#l-l-implicit-document">l-l-implicit-document</a>
    <a href="#l-l-after-document">l-l-after-document</a>? )?
  ( <a href="#c-l-before-document">c-l-before-document</a>
    <a href="#l-l-explicit-document">l-l-explicit-document</a>
    <a href="#l-l-after-document">l-l-after-document</a>? )*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;YAML document stream&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-l-before-document' id='c-l-before-document'><code>[046]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-l-before-document ::=
  <a href="#c-byte-order-mark">c-byte-order-mark</a>?
  <a href="#l-comment-n-">#l-comment(any)</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;comments before actual document starts&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-implicit-document' id='l-l-implicit-document'><code>[047]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-implicit-document ::=
    <a href="#l-l-blk-collection-n-">l-l-blk-collection(any)</a>
  | <a href="#l-l-top-flow-collect-node-n-">l-l-top-flow-collect-node(any)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;first document with an implicit header line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-explicit-document' id='l-l-explicit-document'><code>[048]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-explicit-document ::=
  <a href="#ns-ns-document-header">ns-ns-document-header</a>
  ( <a href="#s-l-top-scalar-node-n-">s-l-top-scalar-node(any)</a>
  | <a href="#s-l-top-collect-node-n-">s-l-top-collect-node(any)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;stream document with an explicit header&nbsp;&#42;/</td>
</tr>
</table>
<div class='level-4'>
<h4><a id='.Document' name='.Document'>3.3.1 Document</a></h4>
<p>A YAML stream may contain several independent YAML documents. A document header line is used to start a new document. This line must start with a document separator: '<code><a href="#ns-ns-document-start">---</a></code>' followed by a line break or a sequence of space characters. If no explicit header line is specified at the start of the stream, the parser should behave as if a header line containing an unadorned '<code>---</code>' was specified.</p>
<p>When YAML is used as the format for a communication stream, it is useful to be able to indicate the end of a document independent of starting the next one. Without such a marker, the YAML processor reading the stream would be forced to wait for the header of the next document (that may be long time in coming) in order to detect the end of the previous document.</p>
<p>To support this scenario, a YAML document may be terminated by a '<code><a href="#ns-ns-document-end">...</a></code>' line. Nothing but throwaway comments may appear between this line and the (mandatory) header line of the following document.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='ns-ns-document-header' id='ns-ns-document-header'><code>[049]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-document-header ::=
  <a href="#ns-ns-document-start">ns-ns-document-start</a>
  ( <a href="#s-char">s-char</a>+ <a href="#c-ns-directive">c-ns-directive</a> )*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;YAML document header&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-document-start' id='ns-ns-document-start'><code>[050]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-document-start ::= '-' '-' '-'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;YAML document start indicator&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-after-document' id='l-l-after-document'><code>[051]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-after-document ::=
  <a href="#ns-ns-document-end">ns-ns-document-end</a> <a href="#b-any">b-any</a>
  <a href="#l-comment-n-">l-comment(any)</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;YAML document trailer&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-document-end' id='ns-ns-document-end'><code>[052]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-document-end ::= '.' '.' '.'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;YAML document end indicator&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
--- &gt;
This YAML stream contains a single text value.
The next stream is a log file - a sequence of
log entries. Adding an entry to the log is a
simple matter of appending it at the end.&nbsp;</pre>
<pre class='example-text'>
---
at: 2001-08-12 09:25:00.00 Z
type: GET
HTTP: '1.0'
url: '/index.html'
---
at: 2001-08-12 09:25:10.00 Z
type: GET
HTTP: '1.0'
url: '/toc.html'&nbsp;</pre>
<pre class='example-text'>
# This stream is an example of a top-level mapping.
invoice : 34843
date    : 2001-01-23
total   : 4443.52&nbsp;</pre>
<pre class='example-text'>
# A one-line alternative syntax for the above document.
[ invoice: 34843, date: 2001-01-23, total: 4443.52 ]&nbsp;</pre>
<pre class='example-text'>
# The following is a stream of three documents. The first is an empty
# mapping, the second an empty sequence, and the last an empty string.
--- {}
--- [ ]
--- ''&nbsp;</pre>
<pre class='example-text'>
# A communication channel based on a YAML stream.
---
sent at: 2002-06-06 11:46:25.10 Z
payload: Whatever
# Receiver can process this as soon as the following is sent:
...
# Even if the next message is sent long after:
---
sent at: 2002-06-06 12:05:53.47 Z
payload: Whatever
...&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-directive-Directive-' name='.-syntax-directive-Directive-'>3.3.2 <a id="syntax-directive" name="syntax-directive">Directive</a></a></h4>
<p>Directives are instructions to the YAML parser. Like <a href="#syntax-throw">throwaway comments</a>, directives are not reflected in the data serialized in the stream. Directives apply to a single document. It is an error for the same directive to be specified more than once for the same document.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-ns-directive' id='c-ns-directive'><code>[053]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-ns-directive ::=
  <a href="#c-directive">c-directive</a> <a href="#ns-ns-directive-name">ns-ns-directive-name</a>
  <a href="#c-mapping-entry">c-mapping-entry</a> <a href="#ns-ns-directive-value">ns-ns-directive-value</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;document directive&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-directive-name' id='ns-ns-directive-name'><code>[054]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-directive-name ::=
  ( <a href="#ns-char">ns-char</a> - <a href="#c-mapping-entry">c-mapping-entry</a> )+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;document directive name&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-directive-value' id='ns-ns-directive-value'><code>[055]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-directive-value ::= <a href="#ns-char">ns-char</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;document directive value&nbsp;&#42;/</td>
</tr>
</table>
<p>This version of YAML defines a single directive, <code>%YAML</code>. Additional directives may be added in future versions of YAML. A parser should ignore unknown directives with an appropriate warning. There is no provision for specifying private directives. This is intentional.</p>
<p>The <code>%YAML</code> directive specifies the version of YAML the document adheres to. This specification defines version <code>1.0</code>.</p>
<p>A version 1.0 parser should accept documents with an explicit <code>%YAML:1.0</code> directive, as well as documents lacking a <code>%YAML</code> directive. Documents with a directive specifying a higher minor version (e.g. <code>%YAML:1.1</code>) should be processed with an appropriate warning. Documents with a directive specifying a higher major version (e.g. <code>%YAML:2.0</code>) should be rejected with an appropriate error message.</p>
</div>
<div class='level-4'>
<h4><a id='.Text-Node' name='.Text-Node'>3.3.3 Text Node</a></h4>
<p>A text node begins at a particular level of indentation, n, and its content is indented at some level &gt;n. A text node can be a <a href="#syntax-collection">collection</a> (<a href="#syntax-mapping">mapping</a> or <a href="#syntax-sequence">sequence</a>), a <a href="#syntax-scalar">scalar</a> (<a href="#c-l-blk-scalar-n-">block</a> or <a href="#ns-ns-flow-scalar-value-n-">flow</a>) or an <a href="#syntax-alias">alias</a>.</p>
<p>A YAML document is a normal node. However a document can't be an alias (there is nothing it may refer to). Also if the header line is omitted the first document must be a collection.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='s-l-top-value-node-n-' id='s-l-top-value-node-n-'><code>[056]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-top-value-node(n) ::=
    <a href="#s-l-top-alias-node">s-l-top-alias-node</a>
  | <a href="#s-l-top-collect-node-n-">s-l-top-collect-node(n)</a>
  | <a href="#s-l-top-scalar-node-n-">s-l-top-scalar-node(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value node outside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-flow-value-node-n-' id='ns-ns-flow-value-node-n-'><code>[057]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-flow-value-node(n) ::=
    <a href="#ns-ns-alias">ns-ns-alias</a>
  | <a href="#c-c-flow-collect-node-n-">c-c-flow-collect-node(n)</a>
  | <a href="#ns-ns-flow-scalar-value-node-n-">ns-ns-flow-scalar-value-node(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value node inside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-s-top-key-node-n-' id='ns-s-top-key-node-n-'><code>[058]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-s-top-key-node(n) ::=
    ( <a href="#c-top-key">c-top-key</a> <a href="#s-l-top-value-node-n-">s-l-top-value-node(&gt;n)</a>
      <a href="#i-spaces-n-">i-spaces(n)</a> )
  | ( <a href="#ns-ns-flow-key-node-n-">ns-ns-flow-key-node(n)</a> <a href="#s-char">s-char</a>* )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;key node outside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-flow-key-node-n-' id='ns-ns-flow-key-node-n-'><code>[059]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-flow-key-node(n) ::=
    <a href="#ns-ns-alias">ns-ns-alias</a>
  | <a href="#c-c-flow-collect-node-n-">c-c-flow-collect-node(n)</a>
  | <a href="#ns-ns-flow-scalar-key-node-n-">ns-ns-flow-scalar-key-node(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;key node inside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-l-top-alias-node' id='s-l-top-alias-node'><code>[060]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-top-alias-node ::=
  <a href="#s-char">s-char</a> <a href="#ns-ns-alias">ns-ns-alias</a>
  <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
  <a href="#l-comment-n-">l-comment(any)</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;alias node outside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-top-flow-collect-node-n-' id='l-l-top-flow-collect-node-n-'><code>[061]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-top-flow-collect-node(n) ::=
  <a href="#i-spaces-n-">i-spaces(n)</a>
  <a href="#c-c-flow-collect-node-n-">c-c-flow-collect-node(n)</a>
  <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
  <a href="#l-comment-n-">l-comment(any)</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;top-level (document) flow collection node&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-l-top-collect-node-n-' id='s-l-top-collect-node-n-'><code>[062]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-top-collect-node(n) ::=
    <a href="#s-l-blk-collect-node-n-">s-l-blk-collect-node(n)</a>
  | ( <a href="#s-s-required-n-">s-s-required(n)</a>
      <a href="#c-c-flow-collect-node-n-">c-c-flow-collect-node(n)</a>
      <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
      <a href="#l-comment-n-">l-comment(any)</a>* )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;collection node outside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-l-blk-collect-node-n-' id='s-l-blk-collect-node-n-'><code>[063]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-blk-collect-node(n) ::=
  ( <a href="#s-char">s-char</a>+ <a href="#c-ns-collect-properties">c-ns-collect-properties</a> )?
  <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
  <a href="#l-comment-n-">l-comment(any)</a>*
  <a href="#l-l-blk-collection-n-">l-l-blk-collection(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;collection node in block style&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-c-flow-collect-node-n-' id='c-c-flow-collect-node-n-'><code>[064]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-c-flow-collect-node(n) ::=
  ( <a href="#c-ns-collect-properties">c-ns-collect-properties</a> <a href="#s-char">s-char</a>+ )?
  <a href="#c-c-flow-collection-n-">c-c-flow-collection(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;collection node inside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-l-top-scalar-node-n-' id='s-l-top-scalar-node-n-'><code>[065]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-top-scalar-node(n) ::=
    <a href="#s-l-blk-scalar-node-n-">s-l-blk-scalar-node(n)</a>
  | ( <a href="#s-s-required-n-">s-s-required(n)</a>
      <a href="#ns-ns-top-scalar-value-node-n-">ns-ns-top-scalar-value-node(n)</a>
      <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
      <a href="#l-comment-n-">l-comment(any)</a>* )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;scalar node outside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-l-blk-scalar-node-n-' id='s-l-blk-scalar-node-n-'><code>[066]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-blk-scalar-node(n) ::=
  ( <a href="#s-char">s-char</a>+ <a href="#c-ns-scalar-properties">c-ns-scalar-properties</a> )?
  <a href="#s-char">s-char</a>+ <a href="#c-l-blk-scalar-n-">c-l-blk-scalar(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;scalar node in block style&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-top-scalar-value-node-n-' id='ns-ns-top-scalar-value-node-n-'><code>[067]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-top-scalar-value-node(n) ::=
  ( <a href="#c-ns-scalar-properties">c-ns-scalar-properties</a> <a href="#s-char">s-char</a>+ )?
  <a href="#ns-ns-top-scalar-value-n-">ns-ns-top-scalar-value(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;scalar node using flow style outside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-flow-scalar-value-node-n-' id='ns-ns-flow-scalar-value-node-n-'><code>[068]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-flow-scalar-value-node(n) ::=
  ( <a href="#c-ns-scalar-properties">c-ns-scalar-properties</a> <a href="#s-char">s-char</a>+ )?
  <a href="#ns-ns-flow-scalar-value-n-">ns-ns-flow-scalar-value(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;scalar value node inside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-flow-scalar-key-node-n-' id='ns-ns-flow-scalar-key-node-n-'><code>[069]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-flow-scalar-key-node(n) ::=
  ( <a href="#c-ns-scalar-properties">c-ns-scalar-properties</a> <a href="#s-char">s-char</a>+ )?
  <a href="#ns-ns-flow-scalar-key-n-">ns-ns-flow-scalar-key(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;scalar key node inside flow collection&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-4'>
<h4><a id='.Node-Property' name='.Node-Property'>3.3.4 Node Property</a></h4>
<p>Each text node may have <a href="#syntax-anchor">anchor</a> and <a href="#syntax-trans">transfer method</a> properties. These properties are specified in a properties list appearing before the node value itself. For a top-level node (a document), the properties appear in the document header line, following the directives (if any). It is an error for the same property to be specified more than once for the same node.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-ns-collect-properties' id='c-ns-collect-properties'><code>[070]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-ns-collect-properties ::=
    ( <a href="#c-ns-collect-transfer">c-ns-collect-transfer</a>
      ( <a href="#s-char">s-char</a>+ <a href="#c-ns-anchor-property">c-ns-anchor-property</a> )? )
  | ( <a href="#c-ns-anchor-property">c-ns-anchor-property</a>
      ( <a href="#s-char">s-char</a>+ <a href="#c-ns-collect-transfer">c-ns-collect-transfer</a> )? )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;collection properties list&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-ns-scalar-properties' id='c-ns-scalar-properties'><code>[071]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-ns-scalar-properties ::=
    ( <a href="#c-ns-scalar-transfer">c-ns-scalar-transfer</a>
      ( <a href="#s-char">s-char</a>+ <a href="#c-ns-anchor-property">c-ns-anchor-property</a> )? )
  | ( <a href="#c-ns-anchor-property">c-ns-anchor-property</a>
      ( <a href="#s-char">s-char</a>+ <a href="#c-ns-scalar-transfer">c-ns-scalar-transfer</a> )? )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;scalar properties list&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-4'>
<h4><a id='.-syntax-trans-Transfer-Method-' name='.-syntax-trans-Transfer-Method-'>3.3.5 <a id="syntax-trans" name="syntax-trans">Transfer Method</a></a></h4>
<p>The transfer method property specifies how to load the associated node. It includes the <a href="#model-type-family">type family</a> for the node and, for global scalar type families, an optional specific <a href="#model-format">format</a> used, separated by a '<code><a href="#c-format">#</a></code>' character.</p>
<p>Like <a href="#syntax-throw">throwaway comments</a> and <a href="#syntax-directive">directives</a>, formats are not reflected in the data serialized in the stream. In contrast, the type family is considered to be part of this data.</p>
<div class='level-5'>
<h5>Explicit/Implicit</h5>
<p>By providing an explicit transfer property to a node, <a href="#trans-implicit">implicit typing</a> is prevented. However, an explicit empty transfer method property can be used to force implicit typing to be applied to a node. If either an empty explicit format or no explicit format are given, the loader automatically detects the format.</p>
<pre class='example-text'>
implicit integer type family: 12
also implicit integer family: ! "12"
explicit integer, implicit format: !int 12
also implicit format: !int# 0x12
explicit format: !int#dec 0x12&nbsp;</pre>
</div>
<div class='level-5'>
<h5>Shorthands</h5>
<p>YAML makes use of the <code>taguri:</code> scheme for defining URIs for its global type families and the <code>x-private:</code> scheme for its private type families. While these schemes provide the necessary semantics for identifying type families, they are rather verbose.</p>
<p>To increase readability, YAML does not use the full URI notation in the stream. Instead, it provides several shorthand notations for different groups of type family URIs. A parser may choose not to expand shorthand type family names to URIs. However, in such a case the parser must still perform <a href="#syntax-trans-esc">escaping</a> to ensure a single unique representation of each type family name.</p>
<ul>
<li>
<div class='seq'>
<p>If the type family begins with a '<code>!</code>' character, it is taken to be a private type family whose URI is under the <code>x-private:</code> scheme. URI fragments are allowed but their semantics is completely up to the semantics of the private type. In particular, they may or may not indicate a format.</p>
<pre class='example-text'>
# Both examples below make use of the 'x-private:ball'
# type family URI, but with different semantics.
---
pool: !!ball { number: 8 }
---
bearing: !!ball { material: steel }&nbsp;</pre>
</div>
</li>
<li>
<div class='seq'>
<p>If the type family contains no '<code>:</code>' and no '<code>/</code>' characters it is assumed to be defined under the <code>yaml.org</code> domain. This domain is used to define the core and universal YAML data types.</p>
<pre class='example-text'>
# The URI is 'taguri:yaml.org,2002:str'
- !str a Unicode string&nbsp;</pre>
</div>
</li>
<li>
<div class='seq'>
<p>Otherwise, if the type family begins with a single word, followed by a '<code>/</code>' character, it is assumed to belong to a sub-domain of <code>yaml.org</code>. Each domain <code><em>vocabulary</em>.yaml.org</code> will include all globally unique types of the vocabulary that aren't covered by the set of universal types. Each vocabulary would contain a set of related types, for example types specific to a particular programming language.</p>
<p>Globally unique types for each language include any built-in types and any standard library types. For languages such as Java and C#, all type names based on reverse DNS strings are globally unique. For languages such as Perl, that has a central authority (<a href="http-www-cpan-org-\">CPAN</a>) for managing the global namespace, all the types sanctioned by the central authority are globally unique. The list of supported languages and their types is maintained as part of the <a href="#trans-repository">YAML type repository</a>.</p>
<pre class='example-text'>
# The URI is 'taguri:perl.yaml.org,2002:Text::Tabs'
- !perl/Text::Tabs {}&nbsp;</pre>
</div>
</li>
<li>
<div class='seq'>
<p>Otherwise, the type family must begin with a domain name and a date (separated by a '<code>,</code>' character), followed by a '<code>/</code>' character. In this case it is taken to be defined under the specified domain and date.</p>
<pre class='example-text'>
# The URI is 'taguri:clarkevans.com,2003-02:timesheet'
- !clarkevans.com,2003-02/timesheet&nbsp;</pre>
</div>
</li>
</ol>
<p>Type families defined in the <code>yaml.org</code> domain or any of its sub-domains must be defined using the appropriate specialized shorthand rather than using the generic domain syntax. This ensures each type family has a unique representation as a shorthand, in addition to having a unique representation as a URI.</p>
</div>
<div class='level-5'>
<h5><a id="syntax-trans-esc" name="syntax-trans-esc">Escaping</a></h5>
<p>YAML allows non-printable Unicode characters to be used in a transfer method using <a href="#syntax-trans-esc">escape sequences</a>.</p>
<pre class='example-text'>
# The following values have the same type family.
- !domain.tld,2002/type\x30 value
- !domain.tld,2002/type0 value&nbsp;</pre>
</div>
<div class='level-5'>
<h5>Expanding</h5>
<p>Sometimes it may be helpful for a YAML type family or transfer method to be expanded to a full URI. A YAML processor may provide a mechanism to perform such expansion. Since URIs support a limited ASCII-based character set, this expansion requires all characters outside this set to be encoded in UTF-8 and the resulting bytes to be encoded using <code>%</code> notation.</p>
<p>When an explicit <code>%</code> character appears in a transfer method, it is passed to the URI form unchanged, allowing explicit <code>%</code> escapes to be used in the transfer method where necessary. It is an error for a transfer method not to have a valid expanded URI format (e.g., contain an invalid explicit <code>%</code> escape sequence).</p>
<pre class='example-text'>
# The following are different as far as YAML is concerned.
- !domain.tld,2002/type%30 value
- !domain.tld,2002/type0 value&nbsp;</pre>
</div>
<div class='level-5'>
<h5>Prefixing</h5>
<p>YAML provides convenient shorthand for the common case where a node and (most of) its descendents have global types families whose shorthand forms share a common prefix. For this case, YAML allows using the '<code><a href="#c-prefix">^</a></code>' character to separate the ancestor node's type family into a prefix and a suffix. The parser does not consider the separator to be part of type family name.</p>
<p>When the parser encounters a descendant node whose type family name begins with '<code>^</code>', it appends the ancestor node's prefix to it. Again the '<code>^</code>' character is not taken to be part of the name.</p>
<p>It is possible for a descendant node to establish a different prefix. In this case the node may not make use of its ancestor's node prefix. It must specify a full type family name, separated into a prefix and suffix as above.</p>
<p>It is an error for a node's type family name to begin with '<code>^</code>' unless it has an ancestor node establishing a prefix. However, a node may establish a prefix even if none of its descendents make use of it.</p>
<p>Note that the type prefix mechanism is purely syntactical and does not imply any additional semantics. In particular, the prefix must not be assumed to be an identifier for anything.</p>
<pre class='example-text'>
# 'taguri:domain.tld,2002:invoice' is some type family.
invoice: !domain.tld,2002/^invoice
  # 'seq' is shorthand for 'taguri:yaml.org,2002:seq'.
  # This does not effect '^customer' below
  # because it is does not specify a prefix.
  customers: !seq
    # '^customer' is shorthand for the full notation
    # '!domain.tld,2002/customer' that stands for the
    # URI 'taguri:domain.tld,2002:customer'.
    - !^customer
      given : Chris
      family : Dumars&nbsp;</pre>
</div>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-prefix' id='c-prefix'><code>[072]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-prefix ::= '^'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;separates prefix from type&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-format' id='c-format'><code>[073]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-format ::= '#'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;separates type from format&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-transfer-char' id='ns-transfer-char'><code>[074]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-transfer-char ::=
    <a href="#ns-esc-sequence">ns-esc-sequence</a>
  | ( <a href="#ns-char">ns-char</a> - <a href="#c-escape">c-escape</a> - <a href="#c-format">c-format</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;characters valid in a transfer metrhod&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-mundane-transfer-char' id='ns-mundane-transfer-char'><code>[075]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-mundane-transfer-char ::=
  <a href="#ns-transfer-char">ns-transfer-char</a> - ':' - '/'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;non-magical URI character&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-ns-collect-transfer' id='c-ns-collect-transfer'><code>[076]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-ns-collect-transfer ::=
  <a href="#c-transfer">c-transfer</a>
  ( /&#42; empty (implicit) &#42;/
  | <a href="#ns-ns-transfer-family">ns-ns-transfer-family</a>
  | ( <em>prefix-of-above</em>?
      <a href="#c-prefix">c-prefix</a>
      <em>suffix-of-above</em> ) )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;collection transfer method (no format)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-ns-scalar-transfer' id='c-ns-scalar-transfer'><code>[077]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-ns-scalar-transfer ::=
  <a href="#c-transfer">c-transfer</a>
  ( /&#42; empty (implicit) &#42;/
  | <a href="#ns-ns-transfer-family">ns-ns-transfer-family</a>
  | <a href="#ns-ns-transfer-format">ns-ns-transfer-format</a>
  | ( <em>prefix-of-above</em>?
      <a href="#c-prefix">c-prefix</a>
      <em>suffix-of-above</em> ) )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;scalar transfer method (with format)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-transfer-family' id='ns-ns-transfer-family'><code>[078]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-transfer-family ::=
  <a href="#c-ns-private-family">c-ns-private-family</a>
  <a href="#ns-ns-global-family">ns-ns-global-family</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;family transfer method (no format)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-transfer-format' id='ns-ns-transfer-format'><code>[079]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-transfer-format ::=
  <a href="#ns-ns-transfer-family">ns-ns-transfer-family</a>
  <a href="#c-format">c-format</a> <a href="#ns-ns-format">ns-ns-format</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;transfer method (with format)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-ns-private-family' id='c-ns-private-family'><code>[080]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-ns-private-family ::=
  <a href="#c-transfer">c-transfer</a> <a href="#ns-transfer-char">ns-transfer-char</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;private type names&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-global-family' id='ns-ns-global-family'><code>[081]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-global-family ::=
    <a href="#ns-ns-core-family">ns-ns-core-family</a>
  | <a href="#ns-ns-vocabulary-family">ns-ns-vocabulary-family</a>
  | <a href="#ns-ns-domain-family">ns-ns-domain-family</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;global type names&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-format' id='ns-ns-format'><code>[082]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-format ::= <a href="#ns-transfer-char">ns-transfer-char</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;format of a scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-core-family' id='ns-ns-core-family'><code>[083]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-core-family ::=
  ( <a href="#ns-mundane-transfer-char">ns-mundane-transfer-char</a>
  - <a href="#c-transfer">c-transfer</a> )
  <a href="#ns-mundane-transfer-char">ns-mundane-transfer-char</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;shorthand for <code>taguri:</code><br />
<code>yaml.org,2002:type</code> names&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-vocabulary-family' id='ns-ns-vocabulary-family'><code>[084]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-vocabulary-family ::=
  <a href="#ns-word-char">ns-word-char</a>+ '/' <a href="#ns-transfer-char">ns-transfer-char</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;shorthand for <code>taguri:vocabulary</code><br />
<code>.yaml.org,2002:type</code> names&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-domain-family' id='ns-ns-domain-family'><code>[085]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-domain-family ::=
  <a href="#ns-word-char">ns-word-char</a>+
  ( '.' <a href="#ns-word-char">ns-word-char</a><code> )</code>
  ',' <a href="#ns-ns-domain-year">ns-ns-domain-year</a>
  ( '-' <a href="#ns-ns-domain-day-month">ns-ns-domain-day-month</a>
    ( '-' <a href="#ns-ns-domain-day-month">ns-ns-domain-day-month</a> )? )?
  '/' <a href="#ns-transfer-char">ns-transfer-char</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;shorthand for <code>taguri:domain,date:type</code> names&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-domain-year' id='ns-ns-domain-year'><code>[086]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-domain-year ::=
  <a href="#ns-decimal-digit">ns-decimal-digit</a> x 4&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;type family domain ownership year&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-domain-day-month' id='ns-ns-domain-day-month'><code>[087]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-domain-day-month ::=
  <a href="#ns-decimal-digit">ns-decimal-digit</a> x 2&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;type family domain ownership day or month (01 by default)&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-4'>
<h4><a id='.-syntax-anchor-Anchor-' name='.-syntax-anchor-Anchor-'>3.3.6 <a id="syntax-anchor" name="syntax-anchor">Anchor</a></a></h4>
<p>An anchor is a property that can be used to mark a node for future reference. An <a href="#syntax-alias">alias node</a> can then be used to indicate additional inclusions of an anchored node by specifying the node's anchor.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-ns-anchor-property' id='c-ns-anchor-property'><code>[088]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-ns-anchor-property ::=
  <a href="#c-anchor">c-anchor</a> <a href="#ns-ns-anchor-name">ns-ns-anchor-name</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;associates an anchor with a given node&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-anchor-name' id='ns-ns-anchor-name'><code>[089]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-anchor-name ::= <a href="#ns-char">ns-char</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;unique anchor name&nbsp;&#42;/</td>
</tr>
</table>
</div>
</div>
<div class='level-3'>
<h3><a id='.-syntax-alias-Alias-' name='.-syntax-alias-Alias-'>3.4 <a id="syntax-alias" name="syntax-alias">Alias</a></a></h3>
<p>An alias node does not directly exist in the data serialized in the stream. Instead, it represents a second occurence of the data represented by the anchored node. The first occurence of the node must be marked by an <a href="#syntax-anchor">anchor</a> to allow additional occurences to be represented as alias nodes.</p>
<p>An alias refers to the most recent <a href="#model-precede">preceding</a> node having the same anchor. It is an error to have an alias use an anchor that does not occur previously in the serialization of the document. It is not an error to have an anchor that is not used by any alias node.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='ns-ns-alias' id='ns-ns-alias'><code>[090]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-alias ::= <a href="#c-alias">c-alias</a> <a href="#ns-ns-anchor-name">ns-ns-anchor-name</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;alias of a preceding anchored node&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
anchor : &amp;A001 This scalar has an anchor.
override : &amp;A001 The alias node below is a repeated use of this value.
alias : *A001&nbsp;</pre>
</div>
<div class='level-3'>
<h3><a id='.-syntax-collection-Collection-' name='.-syntax-collection-Collection-'>3.5 <a id="syntax-collection" name="syntax-collection">Collection</a></a></h3>
<p>Collection nodes come in two kinds, <a href="#syntax-sequence">sequence</a> and <a href="#syntax-mapping">mapping</a>. Each kind has two styles, block and flow. Block styles begin on the next line and use indentation for internal structure. Flow collection styles start on the current line, may span multiple lines, and rely on indicators to represent internal structure.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='l-l-blk-collection-n-' id='l-l-blk-collection-n-'><code>[091]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-blk-collection(n) ::=
    <a href="#l-l-blk-sequence-n-">l-l-blk-sequence(n)</a>
  | <a href="#l-l-blk-mapping-n-">l-l-blk-mapping(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;block collection node styles&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-c-flow-collection-n-' id='c-c-flow-collection-n-'><code>[092]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-c-flow-collection(n) ::=
    <a href="#c-c-flow-sequence-n-">c-c-flow-sequence(n)</a>
  | <a href="#c-c-flow-mapping-n-">c-c-flow-mapping(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;flow collection node styles&nbsp;&#42;/</td>
</tr>
</table>
<p>To enable line spanning in flow collections, wherever tokens may be separated by white space, it is possible to end the line (with an optional throwaway comment) and continue the collection in the next line. Line spanning functionality is indicated by the use of the <a href="#s-s-optional-n-">s-s-optional(n)</a> space and the <a href="#s-s-required-n-">s-s-required(n)</a> space productions.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='s-s-optional-n-' id='s-s-optional-n-'><code>[093]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-s-optional(n) ::=
    <a href="#s-char">s-char</a>*
  | ( <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
      <a href="#i-spaces-n-">i-spaces(n)</a> <a href="#s-char">s-char</a>+ )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;optional white space separating tokens&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-s-required-n-' id='s-s-required-n-'><code>[094]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-s-required(n) ::=
    <a href="#s-char">s-char</a>+
  | ( <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
      <a href="#i-spaces-n-">i-spaces(n)</a> <a href="#s-char">s-char</a>+ )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;required white space separating tokens&nbsp;&#42;/</td>
</tr>
</table>
<div class='level-4'>
<h4><a id='.-syntax-sequence-Sequence-' name='.-syntax-sequence-Sequence-'>3.5.1 <a id="syntax-sequence" name="syntax-sequence">Sequence</a></a></h4>
<p>A sequence node is the simplest node kind. It is a an ordered collection of sub-nodes at a higher indentation level. A flow style is available for short, simple sequences. Also, if a sub-sequence node has no properties, and its first entry is specified without any properties, the sub-sequence node may immediately follow the sequence entry indicator.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='l-l-blk-sequence-n-' id='l-l-blk-sequence-n-'><code>[095]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-blk-sequence(n) ::=
  ( <a href="#i-spaces-n-">i-spaces(n&#91;-1&#93;)</a>
    <a href="#c-l-blk-seq-entry-n-">c-l-blk-seq-entry(n&#91;-1&#93;)</a> )+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;block sequence node; <code>-1</code> unless the block sequence is the value of an entry of a parent block sequence&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-l-blk-seq-entry-n-' id='c-l-blk-seq-entry-n-'><code>[096]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-l-blk-seq-entry(n) ::=
  <a href="#c-sequence-entry">c-sequence-entry</a>
  ( <a href="#s-l-top-value-node-n-">s-l-top-value-node(&gt;n)</a>
  | <a href="#i-l-seq-in-seq-n-">i-l-seq-in-seq(n)</a>
  | <a href="#i-l-map-in-seq-n-">i-l-map-in-seq(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;block sequence node entry&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-l-seq-in-seq-n-' id='i-l-seq-in-seq-n-'><code>[097]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-l-seq-in-seq(n) ::=
  <a href="#i-spaces-n-">i-spaces(m)</a>
  <a href="#c-l-blk-seq-entry-n-">c-l-blk-seq-entry(n&#43;m&#43;1)</a>
  <a href="#l-l-blk-sequence-n-">l-l-blk-sequence(n&#43;m&#43;1)</a>?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;sequence node with no properties in a sequence entry (where <code>m</code>&nbsp;&gt;&nbsp;0)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-c-flow-sequence-n-' id='c-c-flow-sequence-n-'><code>[098]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-c-flow-sequence(n) ::=
  <a href="#c-sequence-start">c-sequence-start</a>
  <a href="#s-s-optional-n-">s-s-optional(n)</a>
  ( <a href="#ns-ns-flow-value-node-n-">ns-ns-flow-value-node(n)</a>
    <a href="#s-s-optional-n-">s-s-optional(n)</a>
    ( <a href="#c-collect-entry">c-collect-entry</a>
      <a href="#s-s-required-n-">s-s-required(n)</a>
      <a href="#ns-ns-flow-value-node-n-">ns-ns-flow-value-node(n)</a>
      <a href="#s-s-optional-n-">s-s-optional(n)</a> )* )?
  <a href="#c-sequence-end">c-sequence-end</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;flow sequence node&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
empty: []
flow: [ one, two, three # May span lines,
         , four,        # indentation is
           five ]       # mostly ignored.
block:
- Note indicator is not indented.
-
 - Subordinate sequence entry (note must be indented).
 - Another entry in subordinate sequence
- - Another way to write a sub-sequence
  - Another entry in sub-sequence
- &gt;
 A folded sequence entry (fifth entry)&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-mapping-Mapping-' name='.-syntax-mapping-Mapping-'>3.5.2 <a id="syntax-mapping" name="syntax-mapping">Mapping</a></a></h4>
<p>A mapping node is an unordered association of unique keys with values. It is an error for two <a href="#model-equality">equal</a> key entries to appear in the same mapping node. In such a case the processor may continue, ignoring the second key and issuing an appropriate warning. This strategy preserves a consistent information model for streaming and random access applications.</p>
<p>A flow form is available for short, simple mapping nodes. Also, if a mapping node has no properties, and its first key is specified as a flow scalar without any properties, this first key may immediately follow the sequence entry indicator.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='l-l-blk-mapping-n-' id='l-l-blk-mapping-n-'><code>[099]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-blk-mapping(n) ::=
  ( <a href="#i-spaces-n-">i-spaces(n)</a>
    <a href="#ns-l-blk-map-entry-n-">ns-l-blk-map-entry(n)</a> )+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;block mapping node&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-l-map-in-seq-n-' id='i-l-map-in-seq-n-'><code>[100]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-l-map-in-seq(n) ::=
  <a href="#i-spaces-n-">i-spaces(m)</a>
  <a href="#ns-ns-flow-scalar-key-n-">ns-ns-flow-scalar-key(n&#43;m&#43;1)</a>
  <a href="#s-char">s-char</a>*
  <a href="#c-mapping-entry">c-mapping-entry</a>
  <a href="#s-l-top-value-node-n-">s-l-top-value-node(&gt;n&#43;m&#43;1)</a>
  <a href="#l-l-blk-mapping-n-">l-l-blk-mapping(n&#43;m&#43;1)</a>?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;mapping node with no properties in a sequence entry (where <code>m</code>&nbsp;&gt;&nbsp;0)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-l-blk-map-entry-n-' id='ns-l-blk-map-entry-n-'><code>[101]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-l-blk-map-entry(n) ::=
  <a href="#ns-s-top-key-node-n-">ns-s-top-key-node(n)</a>
  <a href="#c-mapping-entry">c-mapping-entry</a>
  <a href="#s-l-top-value-node-n-">s-l-top-value-node(&gt;n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;single key:value pair&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-c-flow-mapping-n-' id='c-c-flow-mapping-n-'><code>[102]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-c-flow-mapping(n) ::=
  <a href="#c-mapping-start">c-mapping-start</a>
  <a href="#s-s-optional-n-">s-s-optional(n)</a>
  ( <a href="#ns-ns-flow-map-entry-n-">ns-ns-flow-map-entry(n)</a>
    <a href="#s-s-optional-n-">s-s-optional(n)</a>
    ( <a href="#c-collect-entry">c-collect-entry</a>
      <a href="#s-s-required-n-">s-s-required(n)</a>
      <a href="#ns-ns-flow-map-entry-n-">ns-ns-flow-map-entry(n)</a>
      <a href="#s-s-optional-n-">s-s-optional(n)</a> )* )?
  <a href="#c-mapping-end">c-mapping-end</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;flow mapping node&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-flow-map-entry-n-' id='ns-ns-flow-map-entry-n-'><code>[103]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-flow-map-entry(n) ::=
  <a href="#ns-ns-flow-key-node-n-">ns-ns-flow-key-node(n)</a>
  <a href="#s-char">s-char</a>*
  <a href="#c-mapping-entry">c-mapping-entry</a>
  <a href="#s-s-required-n-">s-s-required(n)</a>
  <a href="#ns-ns-flow-value-node-n-">ns-ns-flow-value-node(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;flow key:value pair&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
empty: {}
flow: { one: 1, two: 2 }
spanning: { one: 1,
   two: 2 }
block:
 key : value
 nested mapping:
  key: Subordinate mapping
 nested sequence:
  - Subordinate sequence
!float 12 : This key is a float.
"\a" : This key had to be escaped.
? '?'
: This key had to be quoted.
? &gt;
 This is a multi
 line folded key
: Whose value is
  also multi-line.
? this also works as a key
: with a value at the next line.
?
 - This key
 - is a sequence
:
 - With a sequence value.
?
 This: key
 is a: mapping
:
 with a: mapping value.
---
- A key: value pair in a sequence.
  A second: key:value pair.
- The previous entry is equal to the following one.
-
 A key:
     value pair in a sequence.
 A second:
     key:value pair.&nbsp;</pre>
</div>
</div>
<div class='level-3'>
<h3><a id='.-syntax-scalar-Scalar-' name='.-syntax-scalar-Scalar-'>3.6 <a id="syntax-scalar" name="syntax-scalar">Scalar</a></a></h3>
<p>While most of the document productions are fairly strict, the scalar production is generous. It offers three flow style variants and two block style variants to choose from, depending upon the readability requirements.</p>
<p><a href="#syntax-throw">Throwaway comments</a> may follow a scalar node, but may not appear inside one. The comment lines following a block scalar node must be less indented than the block scalar value. Empty lines in a scalar node that are followed by a non-empty content line are interpreted as content rather than as implicit comments. Such lines may be less indented than the text content.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-l-blk-scalar-n-' id='c-l-blk-scalar-n-'><code>[104]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-l-blk-scalar(n) ::=
    <a href="#c-l-literal-n-">c-l-literal(n)</a>
  | <a href="#c-l-folded-n-">c-l-folded(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;block scalar styles&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-top-scalar-value-n-' id='ns-ns-top-scalar-value-n-'><code>[105]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-top-scalar-value(n) ::=
    <a href="#c-c-single-quoted-n-">c-c-single-quoted(n)</a>
  | <a href="#c-c-double-quoted-n-">c-c-double-quoted(n)</a>
  | <a href="#ns-ns-plain-top-value-n-">ns-ns-plain-top-value(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;flow scalar value styles outside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-flow-scalar-value-n-' id='ns-ns-flow-scalar-value-n-'><code>[106]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-flow-scalar-value(n) ::=
    <a href="#c-c-single-quoted-n-">c-c-single-quoted(n)</a>
  | <a href="#c-c-double-quoted-n-">c-c-double-quoted(n)</a>
  | <a href="#ns-ns-plain-flow-value-n-">ns-ns-plain-flow-value(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;flow scalar value styles inside flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-flow-scalar-key-n-' id='ns-ns-flow-scalar-key-n-'><code>[107]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-flow-scalar-key(n) ::=
    <a href="#c-c-single-quoted-n-">c-c-single-quoted(n)</a>
  | <a href="#c-c-double-quoted-n-">c-c-double-quoted(n)</a>
  | <a href="#ns-ns-plain-key">ns-ns-plain-key</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;flow scalar key styles&nbsp;&#42;/</td>
</tr>
</table>
<div class='level-4'>
<h4><a id='.-syntax-eol-norm-End-Of-line-Normalization-' name='.-syntax-eol-norm-End-Of-line-Normalization-'>3.6.1 <a id="syntax-eol-norm" name="syntax-eol-norm">End Of line Normalization</a></a></h4>
<p>Inside all scalar nodes, a compliant YAML parser must translate the two-character combination <a href="#b-carriage-return">CR</a> <a href="#b-line-feed">LF</a>, any <a href="#b-carriage-return">CR</a> that is not followed by an <a href="#b-line-feed">LF</a>, and any <a href="#b-next-line">NEL</a> into a single <a href="#b-line-feed">LF</a> (this does not apply to <a href="#syntax-escaping">escaped characters</a>). <a href="#b-line-separator">LS</a> and <a href="#b-paragraph-separator">PS</a> characters are preserved. These rules are compatible with Unicode's <a href="http-www-unicode-org-unicode-reports-tr13-\">newline guidelines</a>.</p>
<p>Normalization functionality is indicated by the use of the <a href="#b-as-line-feed">b-as-line-feed</a> production defined below.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='b-as-line-feed' id='b-as-line-feed'><code>[108]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-as-line-feed ::= <a href="#b-generic">b-generic</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;line break converted to a line feed&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-normalized' id='b-normalized'><code>[109]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-normalized ::=
  <a href="#b-as-line-feed">b-as-line-feed</a> | <a href="#b-specific">b-specific</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;a normalized end of line marker&nbsp;&#42;/</td>
</tr>
</table>
<p>On output, a YAML emitter is free to serialize end of line markers using whatever convention is most appropriate, though again <a href="#b-line-separator">LS</a> and <a href="#b-paragraph-separator">PS</a> must be preserved.</p>
</div>
<div class='level-4'>
<h4><a id='.Block-Modifiers' name='.Block-Modifiers'>3.6.2 Block Modifiers</a></h4>
<p>Each block scalar may have <a href="#syntax-exp-indent">explicit indentation</a> and <a href="#syntax-chomp">chomping</a> modifiers. These modifiers are specified following the block style indicator. It is an error for the same modifier to be specified more than once for the same node.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='ns-ns-blk-modifiers' id='ns-ns-blk-modifiers'><code>[110]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-blk-modifiers ::=
    ( <a href="#ns-explicit-indent">ns-explicit-indent</a>
      <a href="#c-chomp-control">c-chomp-control</a>? )
  | ( <a href="#c-chomp-control">c-chomp-control</a>
      <a href="#ns-explicit-indent">ns-explicit-indent</a>? )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;block scalar modifiers&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-4'>
<h4><a id='.-syntax-exp-indent-Explicit-Indentation-' name='.-syntax-exp-indent-Explicit-Indentation-'>3.6.3 <a id="syntax-exp-indent" name="syntax-exp-indent">Explicit Indentation</a></a></h4>
<p>Typically the indentation level of a block scalar node is detected from its first content line. This detection fails when this first line is empty, contains a leading '<code><a href="#c-throwaway">#</a></code>' character, or contains leading white space characters.</p>
<p>In such cases YAML requires that the indentation level for the scalar node text content be given explicitly. This level is specified as the integer number of the additional indentation spaces used for the text content.</p>
<p>The indentation level is always non-zero, except for the top level node of each document. This node is commonly indented by zero spaces (not indented).</p>
<p>It is always valid to specify an explicit indentation level, though emitters should not do so in cases where detection succeeds. It is an error for detection to fail when there is no explicit indentation specified.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='ns-explicit-indent' id='ns-explicit-indent'><code>[111]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-explicit-indent ::= <a href="#ns-decimal-digit">ns-decimal-digit</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;explicit additional indentation level&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
# Explicit indentation must
# be given in all the three
# following cases.
leading spaces: |2
      This value starts with four spaces.

leading line break: |2

  This value starts with a line break.

leading comment indicator: |2
  # first line starts with a # character.

# Explicit indentation may
# also be given when it is
# not required.
redundant: |2
  This value is indented 2 spaces.

# Indentation may apply to top level nodes.
--- |
Usually top level nodes are not indented.
--- |
  This text is indented two spaces.
  It contains no leading spaces.
--- |0
  This text contains two leading spaces.&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-chomp-Chomping-' name='.-syntax-chomp-Chomping-'>3.6.4 <a id="syntax-chomp" name="syntax-chomp">Chomping</a></a></h4>
<p>Typically the final line break of a block scalar is considered to be a part of its value, and any trailing empty lines are taken to be <a href="#l-empty-comment-n-">comment lines</a>. This default "clip" chomping behavior can be overriden by specifying a chomp control modifier.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-chomp-control' id='c-chomp-control'><code>[112]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-chomp-control ::=
    <a href="#c-strip-chomp">c-strip-chomp</a>
  | <a href="#c-keep-chomp">c-keep-chomp</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;override the default "clip" chomping&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-strip-chomp' id='c-strip-chomp'><code>[113]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-strip-chomp ::= '-'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;strip final line break from value&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='c-keep-chomp' id='c-keep-chomp'><code>[114]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-keep-chomp ::= '+'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;keep trailing line breaks in value&nbsp;&#42;/</td>
</tr>
</table>
<dl>
<dt>
strip ('<code>-</code>')</dt>
<dd>
The '<code>-</code>' chomp control specifies that the final line break character of the block scalar should be stripped from its value.
</dd>
<dt>
keep ('<code>&#43;</code>')</dt>
<dd>
The '<code>&#43;</code>' chomp control specifies that any trailing empty lines following the block scalar should be considered to be a part of its value. If this modifier is not specified, such lines are considered to be empty throwaway comment lines and are ignored.
</dd>
</dl>
<p>When this functionality is implied, the <a href="#l-l-empty-trailing-n-">l-l-empty-trailing(n)</a> production will be used.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='l-l-empty-trailing-n-' id='l-l-empty-trailing-n-'><code>[115]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-empty-trailing(n) ::=
    <a href="#l-empty-comment-n-">l-empty-comment(n)</a>+
  | <a href="#l-blk-empty-line-feed-n-">l-blk-empty-line-feed(n)</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;trailing line feeds or comment lines, depending on chomp control)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-blk-empty-line-feed-n-' id='l-blk-empty-line-feed-n-'><code>[116]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-blk-empty-line-feed(n) ::=
  <a href="#i-spaces-n-">i-spaces(&lt;=n)</a> <a href="#b-as-line-feed">b-as-line-feed</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;empty block line&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
clipped: |
    This has one newline.

same as "clipped" above: "This has one newline.\n"

stripped: |-
    This has no newline.

same as "stripped" above: "This has no newline."

kept: |+
    This has two newlines.

same as "kept" above: "This has two newlines.\n\n"&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-literal-Literal-' name='.-syntax-literal-Literal-'>3.6.5 <a id="syntax-literal" name="syntax-literal">Literal</a></a></h4>
<p>A literal scalar is the simplest scalar form. No processing is performed on literal scalar characters aside from <a href="#syntax-eol-norm">end of line normalization</a> and stripping away the <a href="#syntax-indent">indentation</a>. Indentation is detected from the first content line. <a href="#syntax-exp-indent">Explicit indentation</a> must be specified in case this yields the wrong result.</p>
<p>This restricts literal scalars to printable characters only. Also, long lines can't be broken. In exchange for these restrictions, a literal scalar may use any printable character, including line breaks. This makes literal scalars the most readable format for source code or other text values with significant use of indicators, quotes, escape sequences, and line breaks.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-l-literal-n-' id='c-l-literal-n-'><code>[117]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-l-literal(n) ::=
  <a href="#c-literal">c-literal</a>
  <a href="#ns-ns-blk-modifiers">ns-ns-blk-modifiers</a>?
  <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
  <a href="#l-l-literal-value-n-">l-l-literal-value(n)</a>?
  <a href="#l-l-empty-trailing-n-">l-l-empty-trailing(n)</a>?
  ( <a href="#l-text-comment-n-">l-text-comment(n)</a>
    <a href="#l-comment-n-">l-comment(any)</a>* )?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;literal scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-literal-value-n-' id='l-l-literal-value-n-'><code>[118]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-literal-value(n) ::=
  <a href="#l-l-literal-chunk-n-">l-l-literal-chunk(n)</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value of literal scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-literal-chunk-n-' id='l-l-literal-chunk-n-'><code>[119]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-literal-chunk(n) ::=
  <a href="#l-blk-empty-line-feed-n-">l-blk-empty-line-feed(n)</a>*
  ( <a href="#l-literal-text-n-">l-literal-text(n)</a>
  | <a href="#l-blk-empty-specific-n-">l-blk-empty-specific(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;chunk of literal scalar lines&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-blk-empty-specific-n-' id='l-blk-empty-specific-n-'><code>[120]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-blk-empty-specific(n) ::=
  <a href="#i-spaces-n-">i-spaces(&lt;=n)</a> <a href="#b-specific">b-specific</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;empty block line with preserved specific line break&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-literal-text-n-' id='l-literal-text-n-'><code>[121]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-literal-text(n) ::=
  <a href="#i-spaces-n-">i-spaces(n)</a> <a href="#nb-char">nb-char</a>+ <a href="#b-normalized">b-normalized</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;literal line character data&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
empty: |

literal: |
 The \ ' " characters may be
 freely used. Leading white
    space is significant.

 Line breaks are significant. Thus this value
 contains one empty line and ends with a single
 line break, but does not start with one.

is equal to: "The \\ ' \" characters may \
 be\nfreely used. Leading white\n   space \
 is significant.\n\nLine breaks are \
 significant. Thus this value\ncontains \
 one empty line and ends with a single\nline \
 break, but does not start with one.\n"

# Comments may follow a block scalar value.
# They must be less indented.

# Modifiers may be combined in any order.
indented and chomped: |2-
    This has no newline.

also written as: |-2
    This has no newline.

both are equal to: "  This has no newline."&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-folding-Folding-' name='.-syntax-folding-Folding-'>3.6.6 <a id="syntax-folding" name="syntax-folding">Folding</a></a></h4>
<p>When folding is done, a single <a href="#b-as-line-feed">normalized line feed</a> is converted to a single space (<code>#x20</code>). When two or more consecutive (possibly indented) normalized line feeds are encountered, the parser does not convert them into spaces. Instead, the parser ignores the first of the line feeds and preserves the rest. Thus a single line feed can be serialized as two, two line feeds can be serialized as three, etc.</p>
<p>When folding is done, specific line breaks are preserved and may be safely used to convey text structure.</p>
<div class='level-5'>
<h5>Folding block scalars</h5>
<p>Block scalars are based on indentation to convey structure. Hence leading white space in block scalar lines is always significant. Folding block scalars builds on this fact to offer powerful and intuitive semantics.</p>
<p>In block scalars, folding only applies to line feeds that separate text lines starting with a non-space character. Hence, folding does not apply to leading line feeds, line feeds surrounding an empty line ending with a specific line break, or line feeds surrounding a text line that starts with a space character.</p>
<p>The combined effect of the processing rules above is that each "paragraph" is interpreted as a single line, empty lines are used to represent a line feed, and "more indented" lines are preserved. Also, specific line breaks may be safely used to indicate text structure.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='b-as-space' id='b-as-space'><code>[122]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-as-space ::= <a href="#b-generic">b-generic</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;line feed converted to a space&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-ignored' id='b-ignored'><code>[123]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-ignored ::= <a href="#b-generic">b-generic</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ignored line feed&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-l-blk-trimmed-n-' id='b-l-blk-trimmed-n-'><code>[124]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-l-blk-trimmed(n) ::=
  <a href="#b-ignored">b-ignored</a>
  <a href="#l-blk-empty-line-feed-n-">l-blk-empty-line-feed(n)</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;sequence of line feeds in block scalar&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-5'>
<h5>Folding flow scalars</h5>
<p>Flow scalars depend on explicit indicators to convey structure, rather than indentation. Hence, in such scalars, all line space preceding or following a line break is not considered to be part of the scalar value. Hence folding flow scalars provides a more relaxed, less powerful semantics. In flow scalars, all leading and trailing white space is stripped from each line. All generic line breaks are folded (even if the line was "more indented").</p>
<p>The combined effect of these processing rules is that each "paragraph" is interpreted as a single line, empty lines are used to represent a line feed, and text can be freely "indented" without affecting the scalar value. Again, specific line breaks may be safely used to indicate text structure.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='i-s-ignored-leading-n-' id='i-s-ignored-leading-n-'><code>[125]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-s-ignored-leading(n) ::=
  <a href="#i-spaces-n-">i-spaces(n)</a> <a href="#s-char">s-char</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ignored spaces at start of flow scalar line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-s-ignored-trailing' id='s-s-ignored-trailing'><code>[126]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-s-ignored-trailing ::= <a href="#s-char">s-char</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ignored spaces at end of flow scalar line&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-flow-empty-specific-n-' id='l-flow-empty-specific-n-'><code>[127]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-flow-empty-specific(n) ::=
  ( <a href="#i-spaces-n-">i-spaces(&lt;=n)</a>
  | <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a> )
  <a href="#b-specific">b-specific</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;empty flow line with preserved specific line break&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-flow-empty-line-feed-n-' id='l-flow-empty-line-feed-n-'><code>[128]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-flow-empty-line-feed(n) ::=
  ( <a href="#i-spaces-n-">i-spaces(&lt;=n)</a>
  | <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a> )
  <a href="#b-as-line-feed">b-as-line-feed</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;empty flow line with line break normalized to line feed&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-l-flow-trimmed-n-' id='b-l-flow-trimmed-n-'><code>[129]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-l-flow-trimmed(n) ::=
  <a href="#b-ignored">b-ignored</a>
  <a href="#l-flow-empty-line-feed-n-">l-flow-empty-line-feed(n)</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;sequence of line feeds in flow scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-l-end-flow-line-n-' id='s-l-end-flow-line-n-'><code>[130]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-end-flow-line(n) ::=
  <a href="#s-s-ignored-trailing">s-s-ignored-trailing</a>
  ( <a href="#b-as-space">b-as-space</a>
  | <a href="#b-l-flow-trimmed-n-">b-l-flow-trimmed(n)</a>
  | <a href="#b-specific">b-specific</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;end of a line in a multi-line flow scalar&nbsp;&#42;/</td>
</tr>
</table>
</div>
</div>
<div class='level-4'>
<h4><a id='.-syntax-folded-Folded-' name='.-syntax-folded-Folded-'>3.6.7 <a id="syntax-folded" name="syntax-folded">Folded</a></a></h4>
<p>A folded scalar is similar to a <a href="#syntax-literal">literal scalar</a>. However, unlike a literal scalar, a folded scalar is subject to (block) <a href="#syntax-folding">line folding</a>. This allows long lines to be broken anywhere a space character (<code>#x20</code>) appears, at the cost of requiring an empty line to represent each <a href="#b-line-feed">line feed</a> character.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-l-folded-n-' id='c-l-folded-n-'><code>[131]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-l-folded(n) ::=
  <a href="#c-folded">c-folded</a>
  <a href="#ns-ns-blk-modifiers">ns-ns-blk-modifiers</a>
  <a href="#s-b-trailing-comment">s-b-trailing-comment</a>
  <a href="#l-l-folded-value-n-">l-l-folded-value(n)</a>?
  <a href="#l-l-empty-trailing-n-">l-l-empty-trailing(n)</a>?
  ( <a href="#l-text-comment-n-">l-text-comment(n)</a>
    <a href="#l-comment-n-">l-comment(any)</a>* )?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;folded scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-folded-value-n-' id='l-l-folded-value-n-'><code>[132]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-folded-value(n) ::=
  <a href="#l-blk-empty-line-feed-n-">l-blk-empty-line-feed(n)</a>*
  ( <a href="#l-l-folded-chunk-n-">l-l-folded-chunk(n)</a>
  | <a href="#l-l-non-folded-chunk-n-">l-l-non-folded-chunk(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value of folded scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-folded-chunk-n-' id='l-l-folded-chunk-n-'><code>[133]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-folded-chunk(n) ::=
  ( <a href="#i-nb-folded-paragraph-n-">i-nb-folded-paragraph(n)</a>
    <a href="#b-l-blk-trimmed-n-">b-l-blk-trimmed(n)</a> )*
  <a href="#i-nb-folded-paragraph-n-">i-nb-folded-paragraph(n)</a>
  <a href="#b-l-after-folded-chunk-n-">b-l-after-folded-chunk(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value starting with a chunk of folded text&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-nb-folded-paragraph-n-' id='i-nb-folded-paragraph-n-'><code>[134]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-nb-folded-paragraph(n) ::=
  ( <a href="#i-nb-folded-text-n-">i-nb-folded-text(n)</a>
    <a href="#b-as-space">b-as-space</a> )*
  <a href="#i-nb-folded-text-n-">i-nb-folded-text(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;single content paragraph folded into multiple physical lines&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-nb-folded-text-n-' id='i-nb-folded-text-n-'><code>[135]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-nb-folded-text(n) ::=
  <a href="#i-spaces-n-">i-spaces(n)</a> <a href="#ns-char">ns-char</a> <a href="#nb-char">nb-char</a>*&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;folded text line characters&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='b-l-after-folded-chunk-n-' id='b-l-after-folded-chunk-n-'><code>[136]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-l-after-folded-chunk(n) ::=
  <a href="#b-normalized">b-normalized</a>
  ( <a href="#l-blk-empty-line-feed-n-">l-blk-empty-line-feed(n)</a>*
    <a href="#l-l-non-folded-chunk-n-">l-l-non-folded-chunk(n)</a> )?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;text following a folded text chunk&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-non-folded-chunk-n-' id='l-l-non-folded-chunk-n-'><code>[137]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-non-folded-chunk(n) ::=
  ( <a href="#l-empty-non-folded-n-">l-empty-non-folded(n)</a>
  | <a href="#l-indented-non-folded-n-">l-indented-non-folded(n)</a> )
  <a href="#l-l-folded-value-n-">l-l-folded-value(n)</a>?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value starting with non-folded text chunk&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-empty-non-folded-n-' id='l-empty-non-folded-n-'><code>[138]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-empty-non-folded(n) ::=
  <a href="#i-spaces-n-">i-spaces(&lt;=n)</a> <a href="#b-specific">b-specific</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;not folded due to specific line break&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-indented-non-folded-n-' id='l-indented-non-folded-n-'><code>[139]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-indented-non-folded(n) ::=
  <a href="#i-spaces-n-">i-spaces(n)</a> <a href="#s-char">s-char</a> <a href="#nb-char">nb-char</a>*
  <a href="#b-normalized">b-normalized</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;not folded due to starting white space&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
empty: &gt;

one paragraph: &gt;
 Line feeds are converted to spaces,
 so this value contains no line
 breaks except for the final one.

multiple paragraphs: &gt;2

  An empty line, either at
  the start or in the value:

  Is interpreted as a line
  break. Thus this value
  contains three line breaks.

indented text: &gt;
    This is a folded paragraph
    followed by a list:
     * first entry
     * second entry
    Followed by another folded
    paragraph, another list:

     * first entry

     * second entry

    And a final folded
    paragraph.

above is equal to: |
    This is a folded paragraph followed by a list:
     * first entry
     * second entry
    Followed by another folded paragraph, another list:

     * first entry

     * second entry

    And a final folded paragraph.

# Explicit comments may follow
# but must be less indented.&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-single-Single-Quoted-' name='.-syntax-single-Single-Quoted-'>3.6.8 <a id="syntax-single" name="syntax-single">Single Quoted</a></a></h4>
<p>The single quoted flow scalar style is indicated by surrounding '<code><a href="#c-single-quote">'</a></code>' characters. Therefore, within a single quoted scalar such characters need to be <a href="#ns-escaped-single-quote">escaped</a>. No other form of escaping is done, limiting single quoted scalars to printable characters.</p>
<p>Single quoted scalars are subject to (flow) <a href="#syntax-folding">folding</a>. This allows empty lines to be broken everywhere a single space character (<code>#x20</code>) separates non-space characters, at the cost of requiring an empty line to represent each <a href="#b-line-feed">line feed</a> character.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-c-single-quoted-n-' id='c-c-single-quoted-n-'><code>[140]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-c-single-quoted(n) ::=
  <a href="#c-single-quote">c-single-quote</a>
  <a href="#nb-nb-single-quoted-value-n-">nb-nb-single-quoted-value(n)</a>?
  <a href="#c-single-quote">c-single-quote</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-nb-single-quoted-value-n-' id='nb-nb-single-quoted-value-n-'><code>[141]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-nb-single-quoted-value(n) ::=
    <a href="#nb-nb-one-single-line">nb-nb-one-single-line</a>
  | ( <a href="#nb-l-first-single-line-n-">nb-l-first-single-line(n)</a>
      <a href="#l-l-inner-single-line-n-">l-l-inner-single-line(n)</a>*
      <a href="#i-nb-last-single-line-n-">i-nb-last-single-line(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value of a single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-nb-one-single-line' id='nb-nb-one-single-line'><code>[142]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-nb-one-single-line ::=
  <a href="#nb-single-char">nb-single-char</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;one line value of single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-l-first-single-line-n-' id='nb-l-first-single-line-n-'><code>[143]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-l-first-single-line(n) ::=
  ( <a href="#nb-single-char">nb-single-char</a>* <a href="#ns-single-char">ns-single-char</a> )?
  <a href="#s-l-end-flow-line-n-">s-l-end-flow-line(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;first line of multi-line single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-inner-single-line-n-' id='l-l-inner-single-line-n-'><code>[144]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-inner-single-line(n) ::=
    <a href="#l-flow-empty-specific-n-">l-flow-empty-specific(n)</a>
  | ( <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a>
      <a href="#ns-single-char">ns-single-char</a>
      <a href="#nb-l-first-single-line-n-">nb-l-first-single-line(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;inner line of multi-line single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-nb-last-single-line-n-' id='i-nb-last-single-line-n-'><code>[145]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-nb-last-single-line(n) ::=
  <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a>
  ( <a href="#ns-single-char">ns-single-char</a> <a href="#nb-single-char">nb-single-char</a>* )?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;last line of multi-line single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-escaped-single-quote' id='ns-escaped-single-quote'><code>[146]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-escaped-single-quote ::=
  <a href="#c-single-quote">c-single-quote</a> <a href="#c-single-quote">c-single-quote</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates a single quote&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-single-char' id='nb-single-char'><code>[147]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-single-char ::=
    <a href="#ns-escaped-single-quote">ns-escaped-single-quote</a>
  | ( <a href="#nb-char">nb-char</a> - <a href="#c-single-quote">c-single-quote</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;non-break char valid in a single quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-single-char' id='ns-single-char'><code>[148]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-single-char ::=
  <a href="#nb-single-char">nb-single-char</a> - <a href="#s-char">s-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;non-space char valid in a single quoted scalar&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
empty: ''
second:
  '! : \ etc. can be used freely.'
third: 'a single quote '' must be escaped.'
span: 'this contains
      six spaces

      and one
      line break'
is same as: "this contains six spaces\nand one line break"&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-escaping-Escaping-' name='.-syntax-escaping-Escaping-'>3.6.9 <a id="syntax-escaping" name="syntax-escaping">Escaping</a></a></h4>
<p>Escaping allows YAML scalar nodes to specify arbitrary Unicode characters, using C-style escape codes. Non-escaped nodes are restricted to <a href="#c-printable">printable Unicode characters</a>.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-escape' id='c-escape'><code>[149]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-escape ::= '\'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;indicates an escape sequence&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-escape' id='ns-esc-escape'><code>[150]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-escape ::= <a href="#c-escape">c-escape</a> <a href="#c-escape">c-escape</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;escaped backslash&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-double-quote' id='ns-esc-double-quote'><code>[151]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-double-quote ::=
  <a href="#c-escape">c-escape</a> <a href="#c-double-quote">c-double-quote</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;escaped double quote character&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-bel' id='ns-esc-bel'><code>[152]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-bel ::= <a href="#c-escape">c-escape</a> 'a'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII alert (BEL)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-backspace' id='ns-esc-backspace'><code>[153]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-backspace ::= <a href="#c-escape">c-escape</a> 'b'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII backspace (BS)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-esc' id='ns-esc-esc'><code>[154]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-esc ::= <a href="#c-escape">c-escape</a> 'e'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII escape (ESC)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-form-feed' id='ns-esc-form-feed'><code>[155]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-form-feed ::= <a href="#c-escape">c-escape</a> 'f'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII formfeed (FF)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-line-feed' id='ns-esc-line-feed'><code>[156]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-line-feed ::= <a href="#c-escape">c-escape</a> 'n'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII linefeed (LF)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-return' id='ns-esc-return'><code>[157]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-return ::= <a href="#c-escape">c-escape</a> 'r'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII carriage return (CR)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-tab' id='ns-esc-tab'><code>[158]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-tab ::= <a href="#c-escape">c-escape</a> 't'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII horizontal tab (TAB)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-vertical-tab' id='ns-esc-vertical-tab'><code>[159]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-vertical-tab ::= <a href="#c-escape">c-escape</a> 'v'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII vertical tab (VTAB)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-null' id='ns-esc-null'><code>[160]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-null ::= <a href="#c-escape">c-escape</a> '0'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII zero (NUL)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-space' id='ns-esc-space'><code>[161]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-space ::= <a href="#c-escape">c-escape</a> #20&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;ASCII space (SP)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-non-breaking-space' id='ns-esc-non-breaking-space'><code>[162]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-non-breaking-space ::=
  <a href="#c-escape">c-escape</a> '_'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;Unicode non-breaking space (NBSP)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-next-line' id='ns-esc-next-line'><code>[163]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-next-line ::= <a href="#c-escape">c-escape</a> 'N'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;Unicode next line (NEL)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-line-separator' id='ns-esc-line-separator'><code>[164]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-line-separator ::= <a href="#c-escape">c-escape</a> 'L'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;Unicode line separator (LS)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-paragraph-separator' id='ns-esc-paragraph-separator'><code>[165]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-paragraph-separator ::= <a href="#c-escape">c-escape</a> 'P'&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;Unicode paragraph separator (PS)&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-8-bit' id='ns-esc-8-bit'><code>[166]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-8-bit ::=
  <a href="#c-escape">c-escape</a> 'x' ( <a href="#ns-hex-digit">ns-hex-digit</a> x 2 )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;8-bit character&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-16-bit' id='ns-esc-16-bit'><code>[167]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-16-bit ::=
  <a href="#c-escape">c-escape</a> 'u' ( <a href="#ns-hex-digit">ns-hex-digit</a> x 4 )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;16-bit character&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-32-bit' id='ns-esc-32-bit'><code>[168]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-32-bit ::=
  <a href="#c-escape">c-escape</a> 'U' ( <a href="#ns-hex-digit">ns-hex-digit</a> x 8 )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;32-bit character&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-esc-sequence' id='ns-esc-sequence'><code>[169]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-esc-sequence ::=
    <a href="#ns-esc-escape">ns-esc-escape</a>
  | <a href="#ns-esc-double-quote">ns-esc-double-quote</a>
  | <a href="#ns-esc-bel">ns-esc-bel</a>
  | <a href="#ns-esc-backspace">ns-esc-backspace</a>
  | <a href="#ns-esc-esc">ns-esc-esc</a>
  | <a href="#ns-esc-form-feed">ns-esc-form-feed</a>
  | <a href="#ns-esc-line-feed">ns-esc-line-feed</a>
  | <a href="#ns-esc-return">ns-esc-return</a>
  | <a href="#ns-esc-tab">ns-esc-tab</a>
  | <a href="#ns-esc-vertical-tab">ns-esc-vertical-tab</a>
  | <a href="#ns-esc-null">ns-esc-null</a>
  | <a href="#ns-esc-space">ns-esc-space</a>
  | <a href="#ns-esc-non-breaking-space">ns-esc-non-breaking-space</a>
  | <a href="#ns-esc-next-line">ns-esc-next-line</a>
  | <a href="#ns-esc-line-separator">ns-esc-line-separator</a>
  | <a href="#ns-esc-paragraph-separator">ns-esc-paragraph-separator</a>
  | <a href="#ns-esc-8-bit">ns-esc-8-bit</a>
  | <a href="#ns-esc-16-bit">ns-esc-16-bit</a>
  | <a href="#ns-esc-32-bit">ns-esc-32-bit</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;escape codes in escaped scalars&nbsp;&#42;/</td>
</tr>
</table>
<p>An escaped line break is completely ignored.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='b-escaped' id='b-escaped'><code>[170]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
b-escaped ::= <a href="#c-escape">c-escape</a> <a href="#b-any">b-any</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;escaped (ignored) line break&nbsp;&#42;/</td>
</tr>
</table>
</div>
<div class='level-4'>
<h4><a id='.-syntax-double-Double-Quoted-' name='.-syntax-double-Double-Quoted-'>3.6.10 <a id="syntax-double" name="syntax-double">Double Quoted</a></a></h4>
<p>The double quoted style variant adds <a href="#syntax-escaping">escaping</a> to the <a href="#syntax-single">single quoted</a> style variant. This is indicated by surrounding '<code><a href="#c-double-quote">"</a></code>' characters. Escaping allows arbitrary Unicode characters to be specified at the cost of some verbosity: <a href="#ns-esc-escape">escaping</a> the printable '<code><a href="#c-escape">\</a></code>' and '<code><a href="#c-double-quote">"</a></code>' characters. It is an error for a double quoted value to contain invalid escape sequences.</p>
<p>Like single quoted scalars, double quoted scalars may span multiple lines, resulting in a single space content character for each line break. If the line break is escaped, any white space preceding it is preserved, and the line break and any leading white space in the continuation line are discarded.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='c-c-double-quoted-n-' id='c-c-double-quoted-n-'><code>[171]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
c-c-double-quoted(n) ::=
  <a href="#c-double-quote">c-double-quote</a>
  <a href="#nb-nb-double-quoted-value-n-">nb-nb-double-quoted-value(n)</a>?
  <a href="#c-double-quote">c-double-quote</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-nb-double-quoted-value-n-' id='nb-nb-double-quoted-value-n-'><code>[172]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-nb-double-quoted-value(n) ::=
    <a href="#nb-nb-one-double-line">nb-nb-one-double-line</a>
  | ( <a href="#nb-l-first-double-line-n-">nb-l-first-double-line(n)</a>
      <a href="#l-l-inner-double-line-n-">l-l-inner-double-line(n)</a>*
      <a href="#i-nb-last-double-line-n-">i-nb-last-double-line(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;value of a double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-nb-one-double-line' id='nb-nb-one-double-line'><code>[173]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-nb-one-double-line ::=
  <a href="#nb-double-char">nb-double-char</a>+&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;one line value of double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-l-first-double-line-n-' id='nb-l-first-double-line-n-'><code>[174]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-l-first-double-line(n) ::=
  ( <a href="#nb-double-char">nb-double-char</a>* <a href="#ns-double-char">ns-double-char</a> )?
  <a href="#s-l-end-double-line-n-">s-l-end-double-line(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;first line of multi-line double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-inner-double-line-n-' id='l-l-inner-double-line-n-'><code>[175]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-inner-double-line(n) ::=
    <a href="#l-flow-empty-specific-n-">l-flow-empty-specific(n)</a>
  | ( <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a>
      <a href="#ns-double-char">ns-double-char</a>
      <a href="#nb-l-first-double-line-n-">nb-l-first-double-line(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;inner line of multi-line double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-nb-last-double-line-n-' id='i-nb-last-double-line-n-'><code>[176]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-nb-last-double-line(n) ::=
  <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a>
  ( <a href="#ns-double-char">ns-double-char</a> <a href="#nb-double-char">nb-double-char</a>* )?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;last line of multi-line double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='s-l-end-double-line-n-' id='s-l-end-double-line-n-'><code>[177]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
s-l-end-double-line(n) ::=
    <a href="#s-l-end-flow-line-n-">s-l-end-flow-line(n)</a>
  | ( <a href="#s-char">s-char</a>* <a href="#b-escaped">b-escaped</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;end of a line in a multi-line double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-double-char' id='nb-double-char'><code>[178]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-double-char ::=
    <a href="#ns-esc-sequence">ns-esc-sequence</a>
  | ( <a href="#nb-char">nb-char</a> - <a href="#c-escape">c-escape</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;non-break char valid in a double quoted scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-double-char' id='ns-double-char'><code>[179]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-double-char ::=
  <a href="#nb-double-char">nb-double-char</a> - <a href="#s-char">s-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;non-space char valid in a double quoted scalar&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
empty: ""
second: "! : etc. can be used freely."
third: "a \" or a \\ must be escaped."
fourth:
  "this value ends with an LF.\n"
span: "this contains
  four  \
      spaces"
is equal to: "this contains four  spaces"&nbsp;</pre>
</div>
<div class='level-4'>
<h4><a id='.-syntax-plain-Plain-' name='.-syntax-plain-Plain-'>3.6.11 <a id="syntax-plain" name="syntax-plain">Plain</a></a></h4>
<p>The plain style variant is a restricted form of the <a href="#syntax-single">single quoted</a> style variant. As it has no identifying markers, it may not start or end with white space characters, may not start with most <a href="#syntax-indicators">indicators</a>, and may not contain certain indicators. Also, a plain scalar is subject to <a href="#trans-implicit">implicit typing</a>. This can be avoided by providing an <a href="#trans-explicit">explicit transfer method</a> property.</p>
<p>Since it lacks identifying markers, the restrictions on a plain scalar depends on the context. There are three different such contexts, with increasing restrictions. Top level plain values are the least restricted plain scalar format. While they can't start with <a href="#ns-first-plain-char">most indicators</a>, they may contain any indicator except '&nbsp;<code><a href="#c-throwaway">#</a></code>' and '<code><a href="#c-mapping-entry">:</a></code>&nbsp;'. Plain scalars used in flow collections are further restricted not to contain <a href="#nb-plain-flow-char">flow indicators</a>. Finally, plain keys are further restricted to a single line.</p>
<table summary='Bnf' class='bnf'>
<tr>
<td class='bnf-number'><a name='ns-ns-plain-top-value-n-' id='ns-ns-plain-top-value-n-'><code>[180]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-plain-top-value(n) ::=
  <a href="#ns-ns-plain-value-n-">ns-ns-plain-value(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;avoiding top indicator chars&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-plain-flow-value-n-' id='ns-ns-plain-flow-value-n-'><code>[181]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-plain-flow-value(n) ::=
  <a href="#ns-ns-plain-value-n-">ns-ns-plain-value(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;avoiding flow indicator chars&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-plain-key' id='ns-ns-plain-key'><code>[182]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-plain-key ::=
  <a href="#ns-ns-one-plain-line">ns-ns-one-plain-line</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;plain scalar used as a key; avoiding flow indicator chars&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-plain-value-n-' id='ns-ns-plain-value-n-'><code>[183]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-plain-value(n) ::=
    <a href="#ns-ns-one-plain-line">ns-ns-one-plain-line</a>
  | ( <a href="#ns-l-first-plain-line-n-">ns-l-first-plain-line(n)</a>
      <a href="#l-l-inner-plain-line-n-">l-l-inner-plain-line(n)</a>*
      <a href="#i-ns-last-plain-line-n-">i-ns-last-plain-line(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;plain scalar used as a value&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-ns-one-plain-line' id='ns-ns-one-plain-line'><code>[184]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-ns-one-plain-line ::=
  <a href="#ns-first-plain-char">ns-first-plain-char</a>
  <a href="#nb-ns-plain-text">nb-ns-plain-text</a>?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;plain one-line value&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-l-first-plain-line-n-' id='ns-l-first-plain-line-n-'><code>[185]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-l-first-plain-line(n) ::=
  <a href="#ns-ns-one-plain-line">ns-ns-one-plain-line</a>
  <a href="#s-l-end-flow-line-n-">s-l-end-flow-line(n)</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;first line of multi-line plain scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='l-l-inner-plain-line-n-' id='l-l-inner-plain-line-n-'><code>[186]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
l-l-inner-plain-line(n) ::=
    <a href="#l-flow-empty-specific-n-">l-flow-empty-specific(n)</a>
  | ( <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a>
      <a href="#ns-plain-char">ns-plain-char</a>
      <a href="#nb-ns-plain-text">nb-ns-plain-text</a>?
      <a href="#s-l-end-flow-line-n-">s-l-end-flow-line(n)</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;inner line of multi-line plain scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='i-ns-last-plain-line-n-' id='i-ns-last-plain-line-n-'><code>[187]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
i-ns-last-plain-line(n) ::=
  <a href="#i-s-ignored-leading-n-">i-s-ignored-leading(n)</a>
  ( <a href="#ns-plain-char">ns-plain-char</a>
    <a href="#nb-ns-plain-text">nb-ns-plain-text</a>? )?&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;last line of multi-line plain scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-ns-plain-text' id='nb-ns-plain-text'><code>[188]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-ns-plain-text ::=
  <a href="#nb-plain-char">nb-plain-char</a>* <a href="#ns-plain-char">ns-plain-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;chunk of plain text&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-first-plain-char' id='ns-first-plain-char'><code>[189]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-first-plain-char ::=
    ( <a href="#ns-plain-char">ns-plain-char</a>
    - <a href="#c-sequence-entry">c-sequence-entry</a>
    - <a href="#c-mapping-entry">c-mapping-entry</a>
    - <a href="#c-sequence-start">c-sequence-start</a>
    - <a href="#c-sequence-end">c-sequence-end</a>
    - <a href="#c-mapping-start">c-mapping-start</a>
    - <a href="#c-mapping-end">c-mapping-end</a>
    - <a href="#c-collect-entry">c-collect-entry</a>
    - <a href="#c-top-key">c-top-key</a>
    - <a href="#c-alias">c-alias</a>
    - <a href="#c-anchor">c-anchor</a>
    - <a href="#c-transfer">c-transfer</a>
    - <a href="#c-literal">c-literal</a>
    - <a href="#c-folded">c-folded</a>
    - <a href="#c-single-quote">c-single-quote</a>
    - <a href="#c-double-quote">c-double-quote</a>
    - <a href="#c-throwaway">c-throwaway</a>
    - <a href="#c-directive">c-directive</a>
    - <a href="#c-reserved">c-reserved</a>
  | ( ( <a href="#c-sequence-entry">c-sequence-entry</a>
      | <a href="#c-top-key">c-top-key</a>
      | <a href="#c-mapping-entry">c-mapping-entry</a>
      | <a href="#c-collect-entry">c-collect-entry</a> )
      <a href="#ns-plain-char">ns-plain-char</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;first character in a plain scalar&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-plain-top-char' id='nb-plain-top-char'><code>[190]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-plain-top-char ::=
    ( <a href="#nb-char">nb-char</a>
    - <a href="#c-mapping-entry">c-mapping-entry</a>
    - <a href="#c-throwaway">c-throwaway</a> )
  | ( <a href="#ns-plain-char">ns-plain-char</a>
      <a href="#c-throwaway">c-throwaway</a> )
  | ( <a href="#c-mapping-entry">c-mapping-entry</a>
      <a href="#ns-plain-char">ns-plain-char</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;char allowed in plain scalar used as top level value&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-plain-flow-char' id='nb-plain-flow-char'><code>[191]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-plain-flow-char ::=
    ( <a href="#nb-plain-top-char">nb-plain-top-char</a>
    - <a href="#c-sequence-start">c-sequence-start</a>
    - <a href="#c-sequence-end">c-sequence-end</a>
    - <a href="#c-mapping-start">c-mapping-start</a>
    - <a href="#c-mapping-end">c-mapping-end</a>
    - <a href="#c-collect-entry">c-collect-entry</a> )
  | ( <a href="#c-collect-entry">c-collect-entry</a>
      <a href="#ns-plain-char">ns-plain-char</a> )&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;char allowed in plain scalar used as value in a flow collection&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-plain-key-char' id='nb-plain-key-char'><code>[192]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-plain-key-char ::=
  <a href="#nb-plain-flow-char">nb-plain-flow-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;char allowed in plain scalar used as key&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='nb-plain-char' id='nb-plain-char'><code>[193]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
nb-plain-char ::=
    <a href="#nb-plain-top-char">nb-plain-top-char</a>
  | <a href="#nb-plain-flow-char">nb-plain-flow-char</a>
  | <a href="#nb-plain-key-char">nb-plain-key-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;depending whether reached from top, flow or key plain scalar production&nbsp;&#42;/</td>
</tr>
<tr>
<td class='bnf-number'><a name='ns-plain-char' id='ns-plain-char'><code>[194]</code></a></td>
<td class='bnf-production'>
<pre class='bnf'>
ns-plain-char ::=
  <a href="#nb-plain-char">nb-plain-char</a> - <a href="#s-char">s-char</a>&nbsp;</pre></td>
<td class='bnf-comment'>/&#42;&nbsp;non-space char valid in a plain scalar&nbsp;&#42;/</td>
</tr>
</table>
<pre class='example-text'>
first: There is no unquoted empty string.
second: 12          ## This is an integer.
boolean: -          ## This is (false).
third: !str 12      ## This is a string.
span: this contains
      six spaces

      and one
      line break

indicators: this has no comments.
            #:foo and bar# are
            both text.
flow: [ can span
           lines, # comment
             like
           this ]
note: { one-line keys: but
        multi-line values }&nbsp;</pre>
</div>
</div>
</div>
<div class='level-2'>
<h2><a id='.Information-Models' name='.Information-Models'>4 Information Models</a></h2>
<div class='level-3'>
<h3><a id='.Overview' name='.Overview'>4.1 Overview</a></h3>
<p>Constraints beyond the syntax productions are required for the consistency of generic YAML utilities such as schema language, transformation tool, path selection expressions, and bindings between languages. These constraints are best expressed as a set of models describing the various states of processing YAML. A conforming YAML processor must satisfy these constraints.</p>
<p>YAML processing may be understood in terms of four interacting representations of the data: a textual format, an event stream, a generic node graph and native language data structures. For each one of these representations, there is a corresponding information model.</p>
<p>Translating YAML information between these representations are six processing components: a parser, a linker, a loader, a dumper, a serializer and an emitter. The parser extracts structured information from the text stream. The linker resolves aliases in the resulting tree, creating a directed graph. The loader resolves types and formats and converts this graph to native data structures. The dumper, serializer and emitter perform the inverse operations.</p>
<pre class='example-text'>
  TEXT   -- Parser -&gt; SERIAL --- Linker ---&gt;  GRAPH    -- Loader -&gt;   NATIVE
(syntax) &lt;- Emitter - (tree) &lt;- Serializer - (generic) &lt;- Dumper -- (language)
                                                                        /\
                                                                        ||
                                                                        \/
                                                                   Application&nbsp;</pre>
<p>A processor need not expose the event stream (serial model) or generic view (graph model) and may translate directly between a text stream and the native binding. However, such a direct translation should take place so that the native binding is constructed only from information available in the native model. In particular, information specific to the graph model (format), serial model (alias anchors and pair ordering) and text model (comments and styles) must not be relied upon in the construction of the native representation. Exceptions to this guideline include editors that must operate directly on the syntax.</p>
<dl>
<dt>
<a href="#model-native">native model</a></dt>
<dd>
The native model describes any information which can be represented as YAML. Information native to a specific environment is modeled by YAML as a graph of typed nodes, where nodes in the graph include atomic values called scalars, sequences of nodes, or mappings of nodes from one set to another.
<p>The native model may be implemented by arbitrary native data structures of the programming language used. The only constraint on the native representation is that it preserve the information defined by the native model.</p>
</dd>
<dt>
<a href="#model-graph">graph model</a></dt>
<dd>
The graph model uses formats to provide a view of native data structures in a way which is independent of particular platform, language, or application. This allows for the definition of a generic YAML API and corresponding tools that do not depend on any particular native representation.
<p>Implementations of the graph model are, by necessity, specific to a particular programming language. Such implementations are constrained to provide the information specified by the graph model.</p>
</dd>
<dt>
<a href="#model-serial">serial model</a></dt>
<dd>
The serial model flattens the graph structure into an ordered hierarchy using alias nodes. An alias node is a surrogate used for subsequent occurrences of any kind of node. In this model, mappings are represented as an ordered set of node pairs.
<p>The serial model is often implemented as an event stream, and is important for implementing one-pass operations on YAML data. Again, of necessity implementations are specific to a particular programming language, and are constrained to provide the information required by the serial model.</p>
</dd>
<dt>
<a href="#model-text">text model</a></dt>
<dd>
The text model enhances the serial model with comments, styles and other syntax specific details. YAML text must comply with the syntax productions given in the following section.
<p>YAML text syntax is fully defined by this specification and hence any instance is independent of the particular programming language chosen. This allows the definition of generic YAML tools that may be applied independently of the programming language used, as well as provides a way to interchange data between applications implemented in differing languages.</p>
</dd>
</dl>
<p>The "human" view of YAML data contains presentation elements (comments, styles, anchors, key order, format) that are absent from the "machine" view of the data. In a similar manner, for human readable text, it is frequently desirable to omit data typing information which is often obvious to the human reader and not needed. This is especially true if the information is created by hand, expecting humans to bother with data typing detail is optimistic.</p>
</div>
<div class='level-3'>
<h3><a id='.-model-native-Native-Language-Model-' name='.-model-native-Native-Language-Model-'>4.2 <a id="model-native" name="model-native">Native (Language) Model</a></a></h3>
<p>The native model abstracts data structures of common programming languages. In YAML's view, any native data is viewed as a directed graph of <a href="#model-type-family">typed</a> <a href="#model-native-node">nodes</a>. Nodes that are defined in terms of other nodes are <a href="#model-collection">collections</a> and nodes that are defined independent of any other nodes are <a href="#model-scalar">scalars</a>. YAML supports two kinds of collection nodes, <a href="#model-mapping">mappings</a> and <a href="#model-sequence">sequences</a>. The native model also defines when two different nodes have the <a href="#model-equality">same content</a> and provides a definition of node <a href="#model-identity">identity</a>.</p>
<div class='level-4'>
<h4><a id='.-model-native-node-Native-Node-' name='.-model-native-node-Native-Node-'>4.2.1 <a id="model-native-node" name="model-native-node">Native Node</a></a></h4>
<p>A native node is YAML's building block for data structures. A native node stands for anything from a single integer to a complex data structure such as a complete VRML scene or SQL database. A native node has the following properties:</p>
<dl>
<dt>
type family</dt>
<dd>
Each native node is associated with a <a href="#model-type-family">type family</a>. This association may be based on the native data type of the node or its value. Indirectly each node is also associated with a <a href="#model-kind">kind</a> through its family.
</dd>
<dt>
<a id="model-value" name="model-value">value</a></dt>
<dd>
A node has an associated value. This value must satisfy the constraints specified by the type family. In particular, the value of a collection (mappings and sequences) is given in terms of other nodes, while the value of a scalar is defined independent of any other node.
</dd>
</dl>
</div>
<div class='level-4'>
<h4><a id='.-model-type-family-Type-Family-' name='.-model-type-family-Type-Family-'>4.2.2 <a id="model-type-family" name="model-type-family">Type Family</a></a></h4>
<p>The type family mechanism provides an abstraction of data types that is portable across languages and platforms. Each native binding may have zero or more native concrete types or class constructs that correspond to a given type family.</p>
<p>YAML supports both global and private type families. Global type families have consistent semantics across all YAML documents. Private type families should not be expected to maintain the same semantics in different documents, even if these appear in the same document stream.</p>
<dl>
<dt>
name</dt>
<dd>
Global type family names are URIs under the <code>taguri:</code> scheme. Private type family names are URIs under the <code>x-private:</code> scheme. The <code>taguri:</code> scheme is described in <a href="http-www-taguri-org\">http://www.taguri.org</a>.
<p>YAML only makes use of <code>taguri:</code> URIs that take the form <code>taguri:domain,date:identifier</code>. Specifically, it does not make use of <code>taguri:</code> URIs that are based on an E-mail address. Nor does it make use of URIs outside the <code>taguri:</code> scheme.</p>
</dd>
<dt>
definition</dt>
<dd>
A description of the particular category of information, independent of language and platform.
</dd>
<dt>
<a id="model-kind" name="model-kind">kind</a></dt>
<dd>
<div class='seq'>
<p>Each type family must have a kind that is either a <a href="#model-scalar">scalar</a> or a <a href="#model-collection">collection</a>. There are two kinds of collections, <a href="#model-sequence">sequence</a> and <a href="#model-mapping">mapping</a>. Usually the kind of each type family follows immediately from the definition (for example, integers are scalars while <code>Point</code> structures are mappings). In other cases, deciding on the kind requires a data modeling decision (for example, whether a date is thought of as a single scalar or as a mapping with independent sub-parts).</p>
<dl>
<dt>
<a id="model-scalar" name="model-scalar">scalar</a></dt>
<dd>
Scalar type families are the simplest. The value of a scalar node is defined in some mathematical terms, independent of any other nodes and type families.
</dd>
<dt>
<a id="model-sequence" name="model-sequence">sequence</a></dt>
<dd>
The value of a sequence node is defined as an ordered set of nodes. Each sequence type family may impose additional constraints on these nodes. For example, it may require that they belong to particular type families.
</dd>
<dt>
<a id="model-mapping" name="model-mapping">mapping</a></dt>
<dd>
<div class='seq'>
<p>The value of a mapping node is defined as a <a href="#model-function">function</a> from a <a href="#model-domain">domain</a> to a <a href="#model-range">range</a>. Each mapping type family may impose additional constraints. For example, it may require a specific set of keys and that the value for each key must be of a particular type family.</p>
<dl>
<dt>
<a id="model-domain" name="model-domain">domain</a></dt>
<dd>
A domain is an unordered set of nodes, restricted such that no two nodes in the set may be <a href="#model-equality">equal</a>. Nodes that are members of the domain are often called "keys".
</dd>
<dt>
<a id="model-range" name="model-range">range</a></dt>
<dd>
A range is an unordered set of nodes without restrictions. Nodes that are members of the range are often called "values".
</dd>
<dt>
<a id="model-function" name="model-function">function</a></dt>
<dd>
A function is a rule of correspondence from the <a href="#model-domain">domain</a> onto the <a href="#model-range">range</a> such that there is a unique value in the range assigned to every key in the domain, and every value in the range is assigned to at least one key.
</dd>
</dl>
</div>
</dd>
<dt>
<a id="model-collection" name="model-collection">collection</a></dt>
<dd>
Is possible to think of a sequence as a mapping using a special domain (all integer values between zero and some maximal value). A unified collection model is helpful both for theoretical analysis and in constructing practical YAML tools and APIs.
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class='level-4'>
<h4><a id='.Equivalence' name='.Equivalence'>4.2.3 Equivalence</a></h4>
<p>In most programming languages, there are two distinct manners in which variables can be equivalent.</p>
<dl>
<dt>
<a id="model-identity" name="model-identity">identity</a></dt>
<dd>
The first form of equivalence is by reference, where the two variables refer to the same memory address. We call this equivalence relation "<em>identity</em>".
</dd>
<dt>
<a id="model-equality" name="model-equality">equality</a></dt>
<dd>
<div class='seq'>
<p>The second form of equivalence occurs when two nodes are different (have different memory addresses), but have the same content. We call this second form of equivalence "<em>equality</em>". It follows that when two nodes are identical they are also equal.</p>
<p>Equality is defined between scalar nodes and between collection nodes, as described below.</p>
<dl>
<dt>
scalar equality</dt>
<dd>
Two <a href="#model-scalar">scalar</a> nodes are equal if and only if they have the same <a href="#model-type-family">type family</a> and their <a href="#model-value">values</a> are the same under the type family's <a href="#model-definition">definition</a>
</dd>
<dt>
collection equality</dt>
<dd>
Equality of collections is defined recursively. Two <a href="#model-collection">collection</a> nodes are equal if and only if they have the same <a href="#model-type-family">type family</a> and for each key in the <a href="#model-domain">domain</a> of one, there is a corresponding key in the domain of the other such that both keys are <a href="#model-equality">equal</a> and their corresponding values are equal; here corresponding value refers to the unique node in the <a href="#model-range">range</a> of the collection assigned to the key by the collection's <a href="#model-function">function</a>.
</dd>
</dl>
</div>
</dd>
</dl>
<p>For the purpose of node equivalence, all YAML collection type families are considered to be <em>mutable</em> and all scalar type families are considered to be <em>immutable</em>. It is possible to modify the value of a mutable (collection) node "in place". For immutable (scalar) nodes, it is impossible to do so; instead, modifications require the creation of a new, independent scalar value of the same type family and using it instead. To better understand this distinction, consider the following example:</p>
<pre class='example-text'>
C syntax: |
    struct Point { int x; int y; } p = { 1, 2 };
YAML syntax: !Point { x: 1, y: 2 }&nbsp;</pre>
<p>It is impossible to modify the integer value 1. The only modification possible is constructing a new, unrelated integer value 3 and using this new value for the X coordinate. Performing this replacement would cause the point to change "in place" from <code>{&nbsp;x:&nbsp;1,&nbsp;y:&nbsp;2&nbsp;}</code> to <code>{&nbsp;x:&nbsp;3,&nbsp;y:&nbsp;2&nbsp;}</code>. Thus, in this example points are mutable but integers are not.</p>
<p>For immutable (scalar) type families, the distinction between equal and identical nodes is only of interest for efficiency reasons (reducing memory usage), and has no semantic significance. Hence for such type families a YAML processor may freely replace two equal but separate (non-identical) nodes with two occurrences of the same (identical) node, and vice versa.</p>
<p>For mutable (collection) type families, however, the distinction between equality and indentity is an important part of the information model and a YAML processor is required to preserve node identity.</p>
</div>
<div class='level-4'>
<h4><a id='.Documents-Stream' name='.Documents-Stream'>4.2.4 Documents Stream</a></h4>
<p>A YAML stream is a sequence of disjoint directed graphs, each with a root node.</p>
<dl>
<dt>
stream</dt>
<dd>
A sequence of zero or more <a href="#model-document">document</a> root nodes.
</dd>
<dt>
<a id="model-document" name="model-document">document</a></dt>
<dd>
A top-level <a href="#model-native-node">node</a> that is <a href="#model-disjoint">disjoint</a> from all other root document nodes.
<p>   </p>
<p>The term <code><strong><a id="model-disjoint" name="model-disjoint">disjoint</a></strong></code> means that for any two nodes <code>x</code> and <code>y</code>, there does not exist a third node <code>z</code> that is reachable from both <code>x</code> and <code>y</code>. For any node <code>x</code>, <code>x</code> is <code><strong>reachable</strong></code> from <code>y</code> if and only if either <code>x</code> and <code>y</code> are <a href="#model-identity">identical</a>, or <code>y</code> is a <a href="#model-collection">collection</a> and there exists a node <code>z</code> in the <a href="#model-domain">domain</a> or the <a href="#model-range">range</a> of <code>y</code> such that <code>x</code> is reachable from <code>z</code>.</p>
</dd>
</dl>
</div>
</div>
<div class='level-3'>
<h3><a id='.-model-graph-Graph-Generic-Model-' name='.-model-graph-Graph-Generic-Model-'>4.3 <a id="model-graph" name="model-graph">Graph (Generic) Model</a></a></h3>
<p>To access YAML information through a generic API, scalars must be viewed as strings. Since a native data type may be stringified in more than one way, the graph model extends the <a href="#model-native">native model</a> with the concept of a format. This model allows the operation of generic tools to be defined independent of language. Applications constructing a native binding from the graph model should not use formats for the preservation of important data.</p>
<div class='level-4'>
<h4><a id='.-model-format-Format-' name='.-model-format-Format-'>4.3.1 <a id="model-format" name="model-format">Format</a></a></h4>
<p>It may be possible to write a string value of a scalar in more than one way. For example, an integer value of 255 can also be written in hex as 0xFF. This distinction is covered by the concept of a format. A format defines a way to write the values of a <a href="#model-scalar">scalar</a> type family as Unicode strings. Using formats allows generic YAML APIs to be implemented in terms of such strings and still allow handling of arbitrary native data.</p>
<dl>
<dt>
name</dt>
<dd>
Each format has a name used for <a href="#trans-explicit">explicit typing</a>. This name may also be used as a fragment identifier in combination with the type family URI for general identification. This name must comply with the <a href="#ns-ns-format">format</a> production, and must be unique within the type families it applies to.
</dd>
<dt>
<a id="model-definition" name="model-definition">definition</a></dt>
<dd>
A description of the format as it applies to particular data values.
</dd>
<dt>
regexp</dt>
<dd>
Regular expressions may be provided to allow <a href="#trans-implicit">implicit typing</a> using the string format, or to enable the YAML processor to validate that a given value is indeed compliant with the string format.
</dd>
</dl>
<p>Formats are an extension required by the graph model, and are not part of the native model. Hence, when constructing native data structures from YAML data, format need not be preserved. For example, a YAML integer node should be loaded to a native integer data type, discarding the information that the integer was serialized in hex format.</p>
</div>
<div class='level-4'>
<h4><a id='.Type-Family-Formats' name='.Type-Family-Formats'>4.3.2 Type Family Formats</a></h4>
<p>Each type family used for <a href="#model-scalar">scalar</a> nodes has associated formats. These formats can be separated into two groups, implicit formats and explicit formats. In addition, one of the formats is designated to be the type family's canonical format.</p>
<p>Type families used for <a href="#model-collection">collection</a> nodes do not have any associated formats.</p>
<dl>
<dt>
<a id="model-implicit-format" name="model-implicit-format">implicit formats</a></dt>
<dd>
A set of zero or more formats used for <a href="#trans-implicit">implicit typing</a>. Each format may only be used in a single type family for this purpose.
</dd>
<dt>
explicit formats</dt>
<dd>
A set of zero or more formats used for <a href="#trans-explicit">explicit typing</a>. It is possible for two type families to share the same explicit format, though this practice is discouraged.
</dd>
<dt>
canonical format</dt>
<dd>
In addition to the above, each scalar type family must provide a <code>canonical</code> format. This must be one of the implicit or explicit formats, or a subset of one of these formats. The canonical format must provide exactly one unique string representation for each possible value of the scalar.
</dd>
</dl>
</div>
<div class='level-4'>
<h4><a id='.-model-graph-node-Graph-Node-' name='.-model-graph-node-Graph-Node-'>4.3.3 <a id="model-graph-node" name="model-graph-node">Graph Node</a></a></h4>
<p>In the graph model, each <a href="#model-scalar">scalar</a> node has an associated format that is one of those defined by the node's <a href="#model-type-family">type family</a>. <a href="#model-collection">Collection</a> nodes do not have an associated format. The <a href="#model-value">value</a> of graph scalar nodes is a Unicode string that is a representation of the appropriate native value using the node's format.</p>
</div>
<div class='level-4'>
<h4><a id='.Implicit-Types-and-Formats' name='.Implicit-Types-and-Formats'>4.3.4 Implicit Types and Formats</a></h4>
<p>In the graph model, the type family and format are optional. When a type family or format is missing, we say that it is implicit. If a format is provided, the type family is mandatory. Since the type family is mandatory in the native model, the loader must resolve the type family and format using <a href="#trans-implicit">implicit typing</a>. When native data is converted to YAML, the dumper is responsible for deciding which <a href="#model-graph-node">graph nodes</a> will have explicit type family and format.</p>
<p>Since graph nodes may be implicitly typed, the loader may not be able to determine the type family of the node. Even when the type family is known, the loader may not have an appropriate native type. Therefore, a given YAML document need not have a native binding for every programming language or application.</p>
</div>
</div>
<div class='level-3'>
<h3><a id='.-model-serial-Serial-Tree-Model-' name='.-model-serial-Serial-Tree-Model-'>4.4 <a id="model-serial" name="model-serial">Serial (Tree) Model</a></a></h3>
<p>To allow for YAML to be communicated as a sequence of events, an ordered tree structure must be used instead of a graph. This section describes an extension to the <a href="#model-graph">graph model</a> where the graph is flattened and ordered to provide a serial interface by using aliases for recurring nodes and by imposing key order. Applications constructing a native binding from the serial model should not use these extensions for the preservation of important data.</p>
<div class='level-4'>
<h4><a id='.-model-serial-node-Serial-Node-' name='.-model-serial-node-Serial-Node-'>4.4.1 <a id="model-serial-node" name="model-serial-node">Serial Node</a></a></h4>
<p>To lay out <a href="#model-native-node">graph nodes</a> as a tree structure, a mechanism is needed to manage duplicate occurrences. This is solved using an additional node kind, <a href="#model-alias">alias</a>. The first occurrence of a node is represented using a serial node of the appropriate kind. Subsequent occurrences of either a collection or a scalar are represented by an alias node.</p>
<p>All nodes in the serial model have the following properties in addition to the properties defined in the <a href="#model-graph">graph</a> model:</p>
<dl>
<dt>
<a id="model-parent" name="model-parent">parent</a></dt>
<dd>
The parent property gives access to the <a href="#model-collection">collection</a> that contains the current serial node.
</dd>
<dt>
<a id="model-anchor" name="model-anchor">anchor</a></dt>
<dd>
The anchor is a Unicode string that complies with the <a href="#ns-ns-anchor-name">ns-ns-anchor-name</a> production. The anchor is used to associate the first occurrence of a <a href="#model-graph-node">graph node</a> with subsequent occurrences, via the <a href="#model-alias">alias</a> serial node. This property is optional, provided that the graph node does not occur more than once in the serialization.
</dd>
</dl>
<p>Note that when a serial node is converted to a graph node, the anchor, if any, is not preserved. Likewise the parent property and the alias kind are not preserved as the graph node may be contained in several collections.</p>
</div>
<div class='level-4'>
<h4><a id='.-model-alias-Alias-' name='.-model-alias-Alias-'>4.4.2 <a id="model-alias" name="model-alias">Alias</a></a></h4>
<p>The alias node represents subsequent occurrences of a <a href="#model-graph-node">graph node</a> in the serialization. Like all serial nodes, an alias node has a <a href="#model-parent">parent</a> and an <a href="#model-anchor">anchor</a> property. In addition, an anchor node has a single additional property:</p>
<dl>
<dt>
<a id="model-referent" name="model-referent">referent</a></dt>
<dd>
The <a href="#model-serial-node">serial node</a> serial node that the alias references is the closest <a href="#model-precede">preceding</a> node having the same <a href="#model-anchor">anchor</a>.
</dd>
</dl>
<p>When an alias node is converted into a <a href="#model-graph-node">graph node</a> it becomes a subsequent occurrence of the graph node represented by its <a href="#model-referent">referent</a> node.</p>
</div>
<div class='level-4'>
<h4><a id='.-model-pair-Pair-' name='.-model-pair-Pair-'>4.4.3 <a id="model-pair" name="model-pair">Pair</a></a></h4>
<p>A pair is an ordered set of two <a href="#model-serial-node">serial nodes</a>. The first member of the set is the key and the second member of the set is the value.</p>
</div>
<div class='level-4'>
<h4><a id='.Serial-Mapping' name='.Serial-Mapping'>4.4.4 Serial Mapping</a></h4>
<p>Mapping <a href="#model-serial-node">serial nodes</a> represent the first occurrence of a <a href="#model-mapping">mapping</a> in a given serialization. The <a href="#model-value">value</a> of mapping serial nodes is an ordered set of node pairs.</p>
<p>When a mapping serial node is converted into a <a href="#model-graph-node">graph node</a>, three operations occur. The <a href="#model-domain">domain</a> is constructed with the graph node for each key in its set of pairs. Likewise, the <a href="#model-range">range</a> is constructed with the graph node for each value in its set of pairs. Last, the <a href="#model-function">function</a> is constructed via association of key graph nodes to value graph nodes, as provided by the set of pairs. Note that the ordering of the pairs is explicitly not converted.</p>
</div>
<div class='level-4'>
<h4><a id='.-model-precede-Ordering-' name='.-model-precede-Ordering-'>4.4.5 <a id="model-precede" name="model-precede">Ordering</a></a></h4>
<p>When serializing a YAML graph, every <a href="#model-serial-node">serial node</a> is put into a single linear sequence within a given document through the mapping pair ordering. With the composition of collections, this ordering becomes total. For any two nodes or aliases, <code>x</code> and <code>y</code> we say that <code>x</code> <code><strong>precedes</strong></code> <code>y</code> when any of the following holds:</p>
</div>
<ul>
<li>
<code>x</code> is the <a href="#model-parent">parent</a> of <code>y</code>.
</li>
<li>
<code>x</code> and <code>y</code> are nodes within a <a href="#model-sequence">sequence</a>, and <code>x</code> appears before <code>y</code>.
</li>
<li>
<code>x</code> is a key and <code>y</code> is a value in a given <a href="#model-pair">pair</a>.
</li>
<li>
<code>x</code> and <code>y</code> are nodes in two <a href="#model-pair">pairs</a> within a <a href="#model-mapping">mapping</a>, and the pair containing <code>x</code> comes before the pair containing <code>y</code>.
</li>
<li>
There exists a node <code>z</code> such that <code>x</code> precedes <code>z</code> and <code>z</code> precedes <code>y</code>.
</li>
</ol>
</div>
<div class='level-3'>
<h3><a id='.-model-text-Text-Syntax-Model-' name='.-model-text-Text-Syntax-Model-'>4.5 <a id="model-text" name="model-text">Text (Syntax) Model</a></a></h3>
<p>To enhance readability, a YAML serialization extends the <a href="#model-serial">serial model</a> with syntax styles, comments and directives and other syntactical details. Although the parser may provide this information, applications should take care not to use these features to encode information found in a native binding.</p>
<div class='level-4'>
<h4><a id='.-preview-style-Style-' name='.-preview-style-Style-'>4.5.1 <a id="preview-style" name="preview-style">Style</a></a></h4>
<p>In the syntax, each node has an additional style property, depending on its <a href="#model-kind">kind</a>.</p>
<dl>
<dt>
scalar style</dt>
<dd>
<a href="#model-scalar">Scalar</a> styles include two <a href="#c-l-blk-scalar-n-">block</a> styles and three <a href="#ns-ns-top-scalar-value-n-">flow</a> styles. All but the <a href="#syntax-double">double quoted</a> style are limited to scalars having only printable characters.
</dd>
<dt>
collection style</dt>
<dd>
There are two styles for each of the <a href="#model-collection">collection</a> kinds, a <a href="#l-l-blk-collection-n-">block</a> style and an <a href="#c-c-flow-collection-n-">flow</a> style.
</dd>
</dl>
</div>
<div class='level-4'>
<h4><a id='.Comment' name='.Comment'>4.5.2 Comment</a></h4>
<p>The syntax allows optional comment blocks to be interleaved with the node blocks. Comment blocks may appear before or after any node block. A comment block can't appear inside a scalar node value.</p>
<dl>
<dt>
comment</dt>
<dd>
A comment is a sequence of zero or more Unicode characters complying with the <a href="#c-nb-throwaway-comment">comment</a> productions.
</dd>
</dl>
</div>
<div class='level-4'>
<h4><a id='.Directive' name='.Directive'>4.5.3 Directive</a></h4>
<p>Attached to each <a href="#model-document">document</a> is a document directive section.</p>
<dl>
<dt>
directive section</dt>
<dd>
A <a href="#model-collection">collection</a> of directives to the parser where each member of the <a href="#model-domain">domain</a> and <a href="#model-range">range</a> are <a href="#model-scalar">scalar</a> values matching the <a href="#ns-ns-directive-name">ns-ns-directive-name</a> and <a href="#ns-ns-directive-value">ns-ns-directive-value</a> productions.
</dd>
</dl>
</div>
<div class='level-4'>
<h4><a id='.Details' name='.Details'>4.5.4 Details</a></h4>
<p>The YAML syntax contains multiple mechanisms for increased readability, such as escaping, indentation, folding, line break normalization etc. While the parser may make such details available, they should not be used to encode information required for the construction of the native data.</p>
</div>
</div>
</div>
<div class='level-2'>
<h2><a id='.Type-Families' name='.Type-Families'>5 Type Families</a></h2>
<p>Every <a href="#model-native-node">native node</a> has, by definition, a type family. However this type family may be missing (implicit) from the <a href="#model-graph">graph model</a>. YAML provides three mechanisms for identifying the true type family (and format) of each node.</p>
<dl>
<dt>
<a id="trans-explicit" name="trans-explicit">Explicit Typing</a></dt>
<dd>
A node may be given an explicit <a href="#syntax-trans">transfer method</a> property, specifying the node's type family and optionally its format. If no format is given, the loader needs to select amongst the type family's formats. This is usualy done by matching the value with the regular expressions of each of the implicit and explicit formats provided by the type family to determine the specific format used.
</dd>
<dt>
Default Typing</dt>
<dd>
When no explicit type family is given, the parser assigns the <a href="#trans-str">str</a> type family to all <a href="#syntax-scalar">scalar</a> nodes, except for <a href="#syntax-plain">plain scalars</a>. This is the only case where typing is done by the parser; all other typing is done by the loader. Specifying an explicit empty transfer method disables this and forces such nodes to undergo implicit typing.
</dd>
<dt>
<a id="trans-implicit" name="trans-implicit">Implicit Typing</a></dt>
<dd>
All nodes that are not explicitly typed and do not have a default type family are subject to implicit typing. This can also be forced using the transfer indicator, '<code><a href="#c-transfer">!</a></code>', all by itself. The loader is then responsible for assigning a type family (and format) for such nodes. This is done in an application-specific manner. However, it is common practice to base such implicit typing on the <a href="#model-implicit-format">implicit formats</a> of scalar type families. Similarly, implicit typing of collection nodes may be based on the kind of the collection node and its contents. Implicit typing of a node may also depend on its position in the graph.
<p> </p>
<p>The implicit typing rules depends upon the application. It is possible to parse a document without being aware of these rules. However, without knowledge of these rules, loading an implicitly typed node to native data structures is not possible.</p>
</dd>
</dl>
<p><a id="trans-repository" name="trans-repository">Following</a> is a description of the three mandatory core type families. YAML requires support for the <a href="#trans-seq">seq</a>, <a href="#trans-map">map</a> and <a href="#trans-str">str</a> type families. YAML also provides a list of universal types that are not mandatory in the YAML type repository available at <a href="http-yaml-org-type\">https://yaml.org/type</a>. These types map to native data types in most programming languages or are useful in a wide range of applications. Hence applications are strongly encouraged to make use of them whenever they are appropriate in order to improve interoperability between YAML systems.</p>
<div class='level-3'>
<h3><a id='.-trans-seq-Sequence-' name='.-trans-seq-Sequence-'>5.1 <a id="trans-seq" name="trans-seq">Sequence</a></a></h3>
<p>This type family is typically used for implicitly typing <a href="#syntax-sequence">sequence</a> nodes. Example bindings include the Perl array, Python's list or tuple, and Java's array or vector.</p>
<table summary='YAML type' class='yaml-type'>
<tr>
<td class='yaml-type-label'>URI:</td>
<td class='yaml-type-uri'>
<pre class='yaml-type-uri'>taguri:yaml.org,2002:seq&nbsp;</pre>
</td>
<td width='100%' />
</tr>
<tr>
<td class='yaml-type-label'>Shorthand:</td>
<td colspan='3' class='yaml-type-shorthand'>
<pre class='yaml-type-shorthand'>
!seq&nbsp;</pre>
</td>
</tr>
<tr>
<td class='yaml-type-label'>Definition:</td>
<td colspan='3' class='yaml-type-definition'><p>Collections indexed by sequential integers starting with zero.</p>
</td>
</tr>
<tr>
<td class='yaml-type-label'>Kind:</td>
<td class='yaml-type-kind'><p>Sequence.</p>
</td>
</tr>
</table>
<pre class='example-text'>
# The following are equal seqs
# with different identities.
flow: [ one, two ]
spanning: [ one,
     two ]
block:
  - one
  - two&nbsp;</pre>
</div>
<div class='level-3'>
<h3><a id='.-trans-map-Mapping-' name='.-trans-map-Mapping-'>5.2 <a id="trans-map" name="trans-map">Mapping</a></a></h3>
<p>This type family is typically used for implicitly typing <a href="#syntax-mapping">mapping</a> nodes. Example bindings include the Perl hash, Python's dictionary, and Java's Hashtable.</p>
<table summary='YAML type' class='yaml-type'>
<tr>
<td class='yaml-type-label'>URI:</td>
<td class='yaml-type-uri'>
<pre class='yaml-type-uri'>taguri:yaml.org,2002:map&nbsp;</pre>
</td>
<td width='100%' />
</tr>
<tr>
<td class='yaml-type-label'>Shorthand:</td>
<td colspan='3' class='yaml-type-shorthand'>
<pre class='yaml-type-shorthand'>
!map&nbsp;</pre>
</td>
</tr>
<tr>
<td class='yaml-type-label'>Definition:</td>
<td colspan='3' class='yaml-type-definition'><p>Associative container, where each key is unique in the association and mapped to exactly one value.</p>
</td>
</tr>
<tr>
<td class='yaml-type-label'>Kind:</td>
<td class='yaml-type-kind'><p>Mapping.</p>
</td>
</tr>
</table>
<pre class='example-text'>
# The following are equal maps
# with different identities.
flow: { one: 1, two: 2 }
block:
    one: 1
    two: 2&nbsp;</pre>
</div>
<div class='level-3'>
<h3><a id='.-trans-str-String-' name='.-trans-str-String-'>5.3 <a id="trans-str" name="trans-str">String</a></a></h3>
<p>This type family is used as the default for all <a href="#syntax-scalar">scalar</a> styles with the exception of <a href="#syntax-plain">plain scalars</a>, unless they are given an explicit transfer method property. Also, it is typically used as the default implicit type family for all plain scalars that don't match any other implicit type.</p>
<p>This type is usually bound to the native language's string or character array construct. Note that generic YAML tools should have an immutable (const) interface to such constructs even when the language default is mutable (such as in C/C++).</p>
<table summary='YAML type' class='yaml-type'>
<tr>
<td class='yaml-type-label'>URI:</td>
<td class='yaml-type-uri'>
<pre class='yaml-type-uri'>taguri:yaml.org,2002:str&nbsp;</pre>
</td>
<td width='100%' />
</tr>
<tr>
<td class='yaml-type-label'>Shorthand:</td>
<td colspan='3' class='yaml-type-shorthand'>
<pre class='yaml-type-shorthand'>
!str&nbsp;</pre>
</td>
</tr>
<tr>
<td class='yaml-type-label'>Definition:</td>
<td colspan='3' class='yaml-type-definition'><p>Unicode strings, a sequence of zero or more Unicode characters.</p>
</td>
</tr>
<tr>
<td class='yaml-type-label'>Kind:</td>
<td class='yaml-type-kind'><p>Scalar.</p>
</td>
</tr>
<tr>
<td class='yaml-type-label'>Formats:</td>
</tr>
<tr>
<td colspan=4>
<table summary='Formats' class='yaml-type-formats'>
<tr>
<td class='yaml-format-type'>
default, implicit</td>
<td class='yaml-format-name'>
<pre class='yaml-format-name'>
canonical</pre>
</td>
<td class='yaml-format-regexp'>
<pre class='yaml-format-regexp'>
.*&nbsp;</pre>
</td>
<td class='yaml-format-comment'>
/&#42;&nbsp;any sequence of characters&nbsp;&#42;/</td>
</tr>
</table>
</td>
</tr>
</table>
<pre class='example-text'>
# Assuming an application
# using implicit integers.
- 12     # An integer
- ! "12" # Also an integer.
# The following scalars
# are loaded to the
# string value '1' '2'.
- !str 12
- '12'
- "12"
- "\
 1\
 2"
# Otherwise, everything is a string:
- /foo/bar
- 192.168.1.1&nbsp;</pre>
</div>
</div>
</div>
</body>
</html>
